--[[
    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    â•‘              ZENITH V16.0 (ULTIMATE EDITION)                 â•‘
    â•‘  Enhanced Stealth â€¢ Optimized Performance â€¢ Modern UI        â•‘
    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    Features:
    âœ“ Delta-Time Normalized Flight with Smooth Lerp
    âœ“ Optimized Noclip (Cached Parts System)
    âœ“ Advanced Staff Detection (Startup + Runtime)
    âœ“ Modern Toggle UI with Keybinds
    âœ“ Memory Leak Prevention
    âœ“ Anti-Detection Measures
    âœ“ Connection Cleanup System
]]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local PathfindingService = game:GetService("PathfindingService")
local TextChatService = game:GetService("TextChatService")
local LocalPlayer = Players.LocalPlayer

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                         CONFIGURATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local Settings = {
    Speed = 60,
    Flight = false, -- Start disabled for stealth
    Noclip = false,
    StaffCheck = true,
    LerpWeight = 0.15,
    ESP = false, -- Start disabled for stealth
    
    -- ESP Settings
    ESPBoxColor = Color3.fromRGB(255, 255, 255),
    ESPBoxTransparency = 0.7,
    ESPTextColor = Color3.fromRGB(255, 255, 255),
    ESPMaxDistance = 1000, -- Max render distance in studs
    ESPWallCheck = true, -- Only show players visible through walls
    ESPVisibilityMode = "VisibleOnly", -- "VisibleOnly" or "Always"
    
    -- Humanization (Anti-Detection)
    FlightHumanization = true,
    HumanizeStrength = 0.3, -- How much randomness (0-1)
    MicroAdjustmentInterval = 0.1, -- Seconds between subtle movements
    
    -- Advanced Features
    StreamerMode = false, -- Hides UI and ESP when enabled
    SelectiveNoclip = true, -- Only noclip objects in front (more natural)
    FakeLag = false, -- Position buffering to simulate lag
    FakeLagIntensity = 0.15, -- Delay in seconds (0.1-0.5)
    
    -- Advanced Tools
    AutoWalk = false, -- Smart pathfinding to waypoint
    GhostMode = false, -- Network desync for scouting
    RemoteLogger = false, -- Log FireServer calls
    InventoryScanner = false, -- Scan player inventories
    ChatLogger = false, -- Log private/team chats
    ChatBypass = false, -- Unicode character replacement
    CustomChat = false, -- 3D chat bubbles visible to everyone
    
    -- Custom Chat Settings
    ChatBubbleColor = Color3.fromRGB(255, 255, 255),
    ChatBubbleTransparency = 10, -- Percentage (0-100)
    ChatTextColor = Color3.fromRGB(0, 0, 0),
    ChatFont = Enum.Font.GothamMedium,
    ChatBubbleDuration = 5, -- Seconds before fade
    ChatBoxEnabled = true, -- Show chat input box
    
    -- Smart Features
    AutoWalk = false, -- Smart pathfinding to waypoint
    AutoWalkSpeed = 16, -- Walking speed multiplier
    GhostMode = false, -- Desync character for scouting
    RemoteLogger = false, -- Log selective remote events
    ChatLogger = false, -- Log all chat messages
    
    -- Remote Logger Filters
    LogOnlyClicks = true, -- Only log when you interact with objects
    
    -- UI Customization
    UIBackgroundColor = Color3.fromRGB(20, 20, 25),
    UIAccentColor = Color3.fromRGB(100, 100, 255),
    UITransparency = 0,
    UIFont = Enum.Font.Gotham,
    UITitleFont = Enum.Font.GothamBold,
    UICornerRadius = 12,
    UIGlowEnabled = true,
    UIMinimized = true, -- Start minimized (mobile-friendly)
    
    -- Keybinds
    ToggleFlight = Enum.KeyCode.F,
    ToggleNoclip = Enum.KeyCode.N,
    ToggleESP = Enum.KeyCode.E,
    ToggleUI = Enum.KeyCode.RightControl,
    PanicKey = Enum.KeyCode.P, -- Instantly hide everything
    SpeedUp = Enum.KeyCode.Equal,
    SpeedDown = Enum.KeyCode.Minus,
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                      CLEANUP PREVIOUS SESSIONS
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if _G.ZenithCleanup then 
    _G.ZenithCleanup() 
end

local connections = {}
local cachedParts = {}
local espObjects = {} -- Stores ESP drawings per player
local gui = nil

-- Humanization state
local lastMicroAdjust = 0
local randomSeed = math.random(1000, 9999) -- Unique per session

-- Metamethod hook storage
local hookedHumanoids = {}
local originalMetatable = nil

-- Fake lag system
local positionBuffer = {}
local lastServerUpdate = 0

-- Panic key system (triple tap detection)
local panicTaps = {}
local lastPanicTap = 0
local TRIPLE_TAP_WINDOW = 0.5 -- Seconds between taps

-- Auto-walk system
local autoWalkPath = nil
local autoWalkTarget = nil
local autoWalkWaypoints = {}
local autoWalkCurrentWaypoint = 1

-- Ghost mode system
local ghostPosition = nil
local ghostedCharacter = nil

-- Remote logger system
local remoteLogData = {}
local lastRemoteClick = 0

-- Inventory scanner data
local inventoryData = {}

-- Chat logger data
local chatLogs = {}

-- Custom chat system
local customChatGui = nil
local chatInputBox = nil
local activeChatBubbles = {} -- Track all chat bubbles

-- Auto-walk system
local PathfindingService = game:GetService("PathfindingService")
local autoWalkTarget = nil
local autoWalkPath = nil
local autoWalkConnection = nil

-- Ghost mode system
local ghostActive = false
local ghostOriginalPosition = nil
local ghostClone = nil

-- Remote logger
local remoteLog = {}
local lastClickTime = 0
local CLICK_WINDOW = 0.5 -- Log remotes fired within this time of clicking

-- Chat logger
local chatLog = {}

_G.ZenithCleanup = function()
    for _, conn in ipairs(connections) do 
        if conn and conn.Connected then
            conn:Disconnect() 
        end
    end
    connections = {}
    cachedParts = {}
    
    -- Cleanup ESP objects
    for _, espData in pairs(espObjects) do
        if espData.Folder then
            espData.Folder:Destroy()
        end
    end
    espObjects = {}
    
    -- Reset character state
    local char = LocalPlayer.Character
    if char then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then 
            hum:ChangeState(Enum.HumanoidStateType.GettingUp) 
        end
        -- Re-enable collisions
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
    
    -- Destroy UI
    if gui then
        gui:Destroy()
        gui = nil
    end
    
    print("âœ“ Zenith V16: Cleanup Complete")
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                           UTILITIES
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function GetChar() 
    return LocalPlayer.Character 
end

local function GetHRP() 
    local char = GetChar()
    return char and char:FindFirstChild("HumanoidRootPart") 
end

local function Clamp(value, min, max)
    return math.min(math.max(value, min), max)
end

-- Detect if user is on mobile
local function IsMobile()
    local touchEnabled = UserInputService.TouchEnabled
    local keyboardEnabled = UserInputService.KeyboardEnabled
    local gamepadEnabled = UserInputService.GamepadEnabled
    
    -- Mobile if touch is enabled but keyboard/gamepad are not
    return touchEnabled and not keyboardEnabled and not gamepadEnabled
end

local isMobileDevice = IsMobile()

-- Perlin-like noise for natural movement variance
local function SmoothNoise(x)
    -- Generates smooth random values that change gradually
    local intX = math.floor(x)
    local fracX = x - intX
    
    -- Smoothstep interpolation (more natural than linear)
    local smooth = fracX * fracX * (3 - 2 * fracX)
    
    -- Generate pseudo-random values based on seed
    local v1 = (math.sin(intX * 12.9898 + randomSeed) * 43758.5453) % 1
    local v2 = (math.sin((intX + 1) * 12.9898 + randomSeed) * 43758.5453) % 1
    
    return v1 + (v2 - v1) * smooth
end

-- Generate natural variance for humanization
local function GetHumanizedOffset(time)
    if not Settings.FlightHumanization then
        return Vector3.zero
    end
    
    local strength = Settings.HumanizeStrength
    
    -- Use multiple noise octaves for more natural movement
    local x = (SmoothNoise(time * 0.5) - 0.5) * strength * 2
    local y = (SmoothNoise(time * 0.7 + 100) - 0.5) * strength * 2
    local z = (SmoothNoise(time * 0.6 + 200) - 0.5) * strength * 2
    
    return Vector3.new(x, y, z)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                  METAMETHOD HOOKING (UNDETECTABLE)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--[[
    Instead of changing WalkSpeed/JumpPower directly (detectable),
    we hook the __index metamethod to return fake values when
    anti-cheats check these properties. This makes detection impossible.
]]

local function HookHumanoid(humanoid)
    if hookedHumanoids[humanoid] then return end
    
    -- Store original values
    hookedHumanoids[humanoid] = {
        OriginalWalkSpeed = humanoid.WalkSpeed,
        OriginalJumpPower = humanoid.JumpPower,
        OriginalJumpHeight = humanoid.JumpHeight,
    }
    
    -- Get or create metatable
    local mt = getrawmetatable(game)
    local oldIndex = mt.__index
    local oldNewIndex = mt.__newindex
    
    setreadonly(mt, false)
    
    -- Hook __index to return fake values
    mt.__index = newcclosure(function(t, k)
        if t == humanoid then
            -- Return original values when properties are read
            if k == "WalkSpeed" and hookedHumanoids[humanoid] then
                return hookedHumanoids[humanoid].OriginalWalkSpeed
            elseif k == "JumpPower" and hookedHumanoids[humanoid] then
                return hookedHumanoids[humanoid].OriginalJumpPower
            elseif k == "JumpHeight" and hookedHumanoids[humanoid] then
                return hookedHumanoids[humanoid].OriginalJumpHeight
            end
        end
        return oldIndex(t, k)
    end)
    
    -- Hook __newindex to intercept property changes
    mt.__newindex = newcclosure(function(t, k, v)
        if t == humanoid then
            -- Update our stored "original" values when game tries to change them
            if k == "WalkSpeed" and hookedHumanoids[humanoid] then
                hookedHumanoids[humanoid].OriginalWalkSpeed = v
                return
            elseif k == "JumpPower" and hookedHumanoids[humanoid] then
                hookedHumanoids[humanoid].OriginalJumpPower = v
                return
            elseif k == "JumpHeight" and hookedHumanoids[humanoid] then
                hookedHumanoids[humanoid].OriginalJumpHeight = v
                return
            end
        end
        return oldNewIndex(t, k, v)
    end)
    
    setreadonly(mt, true)
    
    print("âœ“ Hooked Humanoid (Undetectable Mode)")
end

-- Hook current character's humanoid
local function HookCurrentCharacter()
    local char = GetChar()
    if char then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            HookHumanoid(hum)
        end
    end
end

-- Hook on initial load
if GetChar() then
    task.spawn(HookCurrentCharacter)
end

-- Hook new characters
table.insert(connections, LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5)
    HookCurrentCharacter()
end))

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    SELECTIVE NOCLIP SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--[[
    Instead of disabling collision for entire character,
    only noclip objects directly in front of you.
    Looks like a natural glitch instead of obvious cheating.
]]

local PhysicsService = game:GetService("PhysicsService")

local function GetObjectsInFront()
    local hrp = GetHRP()
    if not hrp then return {} end
    
    -- Raycast forward to detect walls/objects
    local direction = hrp.CFrame.LookVector * 5 -- Check 5 studs ahead
    
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = {GetChar()}
    
    local result = workspace:Raycast(hrp.Position, direction, rayParams)
    
    if result and result.Instance then
        return {result.Instance}
    end
    
    return {}
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                      FAKE LAG SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--[[
    Buffers position updates to make movement look like network lag
    instead of speed hacking. Server sees "laggy player" not "cheater".
]]

local function UpdateFakeLag()
    if not Settings.FakeLag then return end
    
    local hrp = GetHRP()
    if not hrp then return end
    
    local currentTime = tick()
    
    -- Add current position to buffer
    table.insert(positionBuffer, {
        Position = hrp.Position,
        Time = currentTime
    })
    
    -- Remove old positions (keep last 2 seconds of data)
    while #positionBuffer > 0 and currentTime - positionBuffer[1].Time > 2 do
        table.remove(positionBuffer, 1)
    end
    
    -- Apply delayed position to simulate lag
    if currentTime - lastServerUpdate >= Settings.FakeLagIntensity then
        lastServerUpdate = currentTime
        
        -- Find position from X seconds ago
        local targetTime = currentTime - Settings.FakeLagIntensity
        local delayedPos = nil
        
        for i = #positionBuffer, 1, -1 do
            if positionBuffer[i].Time <= targetTime then
                delayedPos = positionBuffer[i].Position
                break
            end
        end
        
        -- Occasionally "rubberband" to create realistic lag appearance
        if delayedPos and SmoothNoise(currentTime * 5) > 0.85 then
            -- Small rollback effect (looks like packet loss)
            hrp.CFrame = CFrame.new(delayedPos, delayedPos + hrp.CFrame.LookVector)
            task.wait(0.05)
            hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + hrp.CFrame.LookVector)
        end
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    CHAT BYPASS SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--[[
    Unicode character replacement to bypass Roblox chat filter.
    Uses mathematically similar characters that look identical.
]]

local bypassMap = {
    -- Cyrillic and special Unicode characters
    ['a'] = 'Ğ°', ['A'] = 'Ğ', -- Cyrillic A
    ['e'] = 'Ğµ', ['E'] = 'Ğ•', -- Cyrillic E
    ['o'] = 'Ğ¾', ['O'] = 'Ğ', -- Cyrillic O
    ['p'] = 'Ñ€', ['P'] = 'Ğ ', -- Cyrillic P
    ['c'] = 'Ñ', ['C'] = 'Ğ¡', -- Cyrillic C
    ['x'] = 'Ñ…', ['X'] = 'Ğ¥', -- Cyrillic X
    ['y'] = 'Ñƒ', -- Cyrillic Y
    ['k'] = 'Ğº', ['K'] = 'Ğš', -- Cyrillic K
    ['m'] = 'Ğ¼', ['M'] = 'Ğœ', -- Cyrillic M
    ['h'] = 'Ò»', ['H'] = 'Î—', -- Latin h with descender / Greek Eta
    ['b'] = 'Ğ¬', ['B'] = 'Ğ’', -- Cyrillic B
    ['i'] = 'Ñ–', ['I'] = 'Ğ†', -- Cyrillic I
    ['j'] = 'Ñ˜', ['J'] = 'Ğˆ', -- Cyrillic J
    ['s'] = 'Ñ•', ['S'] = 'Ğ…', -- Cyrillic S
    ['t'] = 'Ñ‚', ['T'] = 'Ğ¢', -- Cyrillic T
    ['u'] = 'Ï…', ['U'] = 'Î¥', -- Greek Upsilon
    ['v'] = 'Î½', ['V'] = 'Ñ´', -- Greek Nu
    ['w'] = 'Ô', ['W'] = 'Ôœ', -- Cyrillic W
    ['n'] = 'Ğ¿', -- Cyrillic N-like
    ['g'] = 'É¡', -- Latin small letter G
    ['d'] = 'Ô', -- Cyrillic D
    ['f'] = 'f', -- Keep regular (no good replacement)
    ['l'] = 'Ó', ['L'] = 'Ó€', -- Cyrillic palochka
    ['z'] = 'á´¢', ['Z'] = 'Î–', -- Small caps Z / Greek Zeta
    ['q'] = 'Ô›', ['Q'] = 'Ôš', -- Cyrillic Q
    ['r'] = 'Ğ³', ['R'] = 'Ğ¯', -- Cyrillic R-like
}

local function BypassText(text)
    if not Settings.ChatBypass then return text end
    
    local result = ""
    local charCount = 0
    
    for i = 1, #text do
        local char = text:sub(i, i)
        charCount = charCount + 1
        
        -- Replace every 2nd character to avoid pattern detection
        if charCount % 2 == 0 and bypassMap[char] then
            result = result .. bypassMap[char]
        else
            result = result .. char
        end
    end
    
    return result
end

-- Hook chat to automatically bypass
local function HookChat()
    -- Hook TextChatService (new chat)
    pcall(function()
        local chatInputBar = TextChatService.ChatInputBarConfiguration
        local originalSendMessage = chatInputBar.SendButtonSettings
        
        -- Override chat sending
        game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest.OnClientEvent:Connect(function(message)
            if Settings.ChatBypass then
                local bypassed = BypassText(message)
                return bypassed
            end
        end)
    end)
    
    -- Hook legacy chat system
    pcall(function()
        local chatService = require(game:GetService("Chat"):WaitForChild("ClientChatModules"):WaitForChild("ChatSettings"))
        local oldFormat = chatService.GetMessage
        
        chatService.GetMessage = function(...)
            local result = oldFormat(...)
            if Settings.ChatBypass then
                return BypassText(result)
            end
            return result
        end
    end)
    
    print("âœ“ Chat Bypass System Hooked")
end

task.spawn(HookChat)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    CHAT LOGGER SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function LogChat(player, message, channel)
    if not Settings.ChatLogger then return end
    
    table.insert(chatLogs, {
        Player = player.Name,
        Message = message,
        Channel = channel,
        Time = os.date("%H:%M:%S")
    })
    
    -- Keep only last 100 messages
    if #chatLogs > 100 then
        table.remove(chatLogs, 1)
    end
    
    print(string.format("[%s] [%s] %s: %s", os.date("%H:%M:%S"), channel, player.Name, message))
end

-- Hook TextChatService (new chat)
pcall(function()
    TextChatService.MessageReceived:Connect(function(message)
        if message.TextSource then
            local player = Players:GetPlayerByUserId(message.TextSource.UserId)
            if player then
                local channel = "ALL"
                if message.TextChannel.Name:match("Team") then
                    channel = "TEAM"
                elseif message.TextChannel.Name:match("Whisper") then
                    channel = "WHISPER"
                end
                LogChat(player, message.Text, channel)
            end
        end
    end)
end)

-- Hook legacy chat
pcall(function()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local chatEvents = ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents")
    
    chatEvents.OnNewMessage.OnClientEvent:Connect(function(messageData)
        if messageData.FromSpeaker then
            local player = Players:FindFirstChild(messageData.FromSpeaker)
            if player then
                LogChat(player, messageData.Message, messageData.OriginalChannel or "ALL")
            end
        end
    end)
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    REMOTE EVENT LOGGER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
    local method = getnamecallmethod()
    local args = {...}
    
    if Settings.RemoteLogger and method == "FireServer" then
        local currentTime = tick()
        
        -- Only log if within 0.5s of a mouse click (selective logging)
        if currentTime - lastRemoteClick < 0.5 then
            table.insert(remoteLogData, {
                Remote = self:GetFullName(),
                Method = method,
                Args = args,
                Time = os.date("%H:%M:%S")
            })
            
            print(string.format("ğŸ”¥ [Remote] %s | Args: %s", self.Name, table.concat(args, ", ")))
            
            -- Keep only last 50 logs
            if #remoteLogData > 50 then
                table.remove(remoteLogData, 1)
            end
        end
    end
    
    return oldNamecall(self, ...)
end)

-- Track mouse clicks for selective logging
UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        lastRemoteClick = tick()
    end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    INVENTORY SCANNER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function ScanInventories()
    if not Settings.InventoryScanner then return end
    
    inventoryData = {}
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local data = {
                Player = player.Name,
                Backpack = {},
                Character = {}
            }
            
            -- Scan backpack
            if player:FindFirstChild("Backpack") then
                for _, tool in ipairs(player.Backpack:GetChildren()) do
                    if tool:IsA("Tool") then
                        table.insert(data.Backpack, tool.Name)
                    end
                end
            end
            
            -- Scan character
            if player.Character then
                for _, tool in ipairs(player.Character:GetChildren()) do
                    if tool:IsA("Tool") then
                        table.insert(data.Character, tool.Name)
                    end
                end
            end
            
            if #data.Backpack > 0 or #data.Character > 0 then
                inventoryData[player.Name] = data
            end
        end
    end
end

-- Auto-scan every 5 seconds when enabled
task.spawn(function()
    while true do
        task.wait(5)
        if Settings.InventoryScanner then
            ScanInventories()
        end
    end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    GHOST MODE (NETWORK DESYNC)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function EnableGhostMode()
    local char = GetChar()
    local hrp = GetHRP()
    if not (char and hrp) then return end
    
    -- Save original position
    ghostPosition = hrp.CFrame
    
    -- Create invisible clone for local view
    ghostedCharacter = char:Clone()
    ghostedCharacter.Parent = workspace
    
    -- Make clone transparent
    for _, part in ipairs(ghostedCharacter:GetDescendants()) do
        if part:IsA("BasePart") then
            part.Transparency = 0.7
            part.CanCollide = false
        end
    end
    
    -- Move real character far away (network desync)
    char.Parent = nil
    
    print("ğŸ‘» Ghost Mode: Enabled (You're desynced from the server)")
end

local function DisableGhostMode()
    local char = GetChar()
    if not char then return end
    
    -- Restore character
    char.Parent = workspace
    
    -- Teleport back to saved position
    if ghostPosition then
        local hrp = GetHRP()
        if hrp then
            hrp.CFrame = ghostPosition
        end
    end
    
    -- Remove clone
    if ghostedCharacter then
        ghostedCharacter:Destroy()
        ghostedCharacter = nil
    end
    
    ghostPosition = nil
    
    print("ğŸ‘» Ghost Mode: Disabled (Re-synced with server)")
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    SMART AUTO-WALK (PATHFINDING)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function WalkToTarget(target)
    local char = GetChar()
    local hrp = GetHRP()
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    
    if not (hrp and hum and target) then return end
    
    -- Create path
    local path = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        AgentCanClimb = false,
        WaypointSpacing = 4,
        Costs = {
            Water = 20,
            Danger = math.huge
        }
    })
    
    -- Compute path
    local success, errorMsg = pcall(function()
        path:ComputeAsync(hrp.Position, target)
    end)
    
    if not success or path.Status ~= Enum.PathStatus.Success then
        warn("âš ï¸ Path failed:", errorMsg)
        return
    end
    
    -- Get waypoints
    autoWalkWaypoints = path:GetWaypoints()
    autoWalkCurrentWaypoint = 1
    autoWalkPath = path
    
    print("ğŸš¶ Auto-Walk: Path computed (" .. #autoWalkWaypoints .. " waypoints)")
end

-- Auto-walk update loop
task.spawn(function()
    while true do
        RunService.Heartbeat:Wait()
        
        if Settings.AutoWalk and autoWalkWaypoints and #autoWalkWaypoints > 0 then
            local char = GetChar()
            local hrp = GetHRP()
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            
            if hrp and hum and autoWalkCurrentWaypoint <= #autoWalkWaypoints then
                local waypoint = autoWalkWaypoints[autoWalkCurrentWaypoint]
                
                -- Move to waypoint
                hum:MoveTo(waypoint.Position)
                
                -- Apply humanized speed variation
                local baseSpeed = 16
                local speedVariation = SmoothNoise(tick() * 2) * 4 -- Â±2 speed
                hum.WalkSpeed = baseSpeed + speedVariation
                
                -- Slow down when turning (realistic)
                local direction = (waypoint.Position - hrp.Position).Unit
                local facingDirection = hrp.CFrame.LookVector
                local turnAngle = math.acos(direction:Dot(facingDirection))
                
                if turnAngle > math.rad(30) then
                    hum.WalkSpeed = hum.WalkSpeed * 0.7 -- Slow down 30% when turning
                end
                
                -- Check if reached waypoint
                if (hrp.Position - waypoint.Position).Magnitude < 4 then
                    autoWalkCurrentWaypoint = autoWalkCurrentWaypoint + 1
                    
                    -- Jump if needed
                    if waypoint.Action == Enum.PathWaypointAction.Jump then
                        hum.Jump = true
                    end
                end
                
                -- Path completed
                if autoWalkCurrentWaypoint > #autoWalkWaypoints then
                    Settings.AutoWalk = false
                    autoWalkWaypoints = {}
                    print("âœ“ Auto-Walk: Destination reached")
                end
            end
        end
    end
end)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    SMART AUTO-WALK SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--[[
    Uses PathfindingService to walk naturally to waypoints.
    Applies humanization to walking speed around corners.
]]

local function StartAutoWalk(targetPosition)
    local char = GetChar()
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local hrp = GetHRP()
    
    if not (char and hum and hrp) then return end
    
    -- Create path
    autoWalkPath = PathfindingService:CreatePath({
        AgentRadius = 2,
        AgentHeight = 5,
        AgentCanJump = true,
        WaypointSpacing = 4,
        Costs = {
            Water = 20,
            Danger = math.huge
        }
    })
    
    -- Compute path
    local success, errorMsg = pcall(function()
        autoWalkPath:ComputeAsync(hrp.Position, targetPosition)
    end)
    
    if not success or autoWalkPath.Status ~= Enum.PathStatus.Success then
        warn("Auto-Walk: Path computation failed")
        return
    end
    
    local waypoints = autoWalkPath:GetWaypoints()
    local currentWaypointIndex = 1
    
    -- Stop any existing auto-walk
    if autoWalkConnection then
        autoWalkConnection:Disconnect()
    end
    
    -- Walk along path
    autoWalkConnection = RunService.Heartbeat:Connect(function()
        if not Settings.AutoWalk or currentWaypointIndex > #waypoints then
            if autoWalkConnection then
                autoWalkConnection:Disconnect()
                autoWalkConnection = nil
            end
            hum:MoveTo(hrp.Position)
            return
        end
        
        local waypoint = waypoints[currentWaypointIndex]
        local distance = (hrp.Position - waypoint.Position).Magnitude
        
        -- Jump if needed
        if waypoint.Action == Enum.PathWaypointAction.Jump then
            hum:ChangeState(Enum.HumanoidStateType.Jumping)
        end
        
        -- Calculate dynamic speed based on turning angle (humanization)
        if currentWaypointIndex < #waypoints then
            local nextWaypoint = waypoints[currentWaypointIndex + 1]
            local currentDir = (waypoint.Position - hrp.Position).Unit
            local nextDir = (nextWaypoint.Position - waypoint.Position).Unit
            local turnAngle = math.acos(Clamp(currentDir:Dot(nextDir), -1, 1))
            
            -- Slow down on sharp turns (natural behavior)
            local speedMultiplier = 1 - (turnAngle / math.pi) * 0.4
            speedMultiplier = speedMultiplier * (0.9 + SmoothNoise(tick() * 2) * 0.2) -- Add variance
            
            hum.WalkSpeed = Settings.AutoWalkSpeed * speedMultiplier
        else
            hum.WalkSpeed = Settings.AutoWalkSpeed
        end
        
        -- Move to waypoint
        hum:MoveTo(waypoint.Position)
        
        -- Next waypoint when close enough
        if distance < 4 then
            currentWaypointIndex = currentWaypointIndex + 1
        end
    end)
    
    print("âœ“ Auto-Walk: Path created with " .. #waypoints .. " waypoints")
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    CUSTOM CHAT SYSTEM (3D BUBBLES)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--[[
    Creates Roblox-style chat bubbles using BillboardGui.
    Bypasses age-restricted chat filters since it's not using Chat API.
    Everyone in the server can see these, verified or not.
]]

local function CreateChatBubble(character, message)
    if not Settings.CustomChat then return end
    if not character or not character:FindFirstChild("Head") then return end
    
    local head = character.Head
    
    -- Create billboard GUI
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ZenithChatBubble"
    billboard.Adornee = head
    billboard.Size = UDim2.new(0, 300, 0, 100)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = head
    
    -- Chat bubble background (rounded rectangle)
    local bubble = Instance.new("Frame")
    bubble.Size = UDim2.new(0, 0, 0, 0) -- Will be resized
    bubble.AnchorPoint = Vector2.new(0.5, 1)
    bubble.Position = UDim2.new(0.5, 0, 1, 0)
    bubble.BackgroundColor3 = Settings.ChatBubbleColor
    bubble.BackgroundTransparency = Settings.ChatBubbleTransparency / 100
    bubble.BorderSizePixel = 0
    bubble.Parent = billboard
    
    local bubbleCorner = Instance.new("UICorner")
    bubbleCorner.CornerRadius = UDim.new(0, 12)
    bubbleCorner.Parent = bubble
    
    -- Add subtle shadow/stroke
    local bubbleStroke = Instance.new("UIStroke")
    bubbleStroke.Color = Color3.fromRGB(0, 0, 0)
    bubbleStroke.Thickness = 1
    bubbleStroke.Transparency = 0.8
    bubbleStroke.Parent = bubble
    
    -- Padding for text
    local padding = Instance.new("UIPadding")
    padding.PaddingLeft = UDim.new(0, 12)
    padding.PaddingRight = UDim.new(0, 12)
    padding.PaddingTop = UDim.new(0, 8)
    padding.PaddingBottom = UDim.new(0, 8)
    padding.Parent = bubble
    
    -- Chat text
    local text = Instance.new("TextLabel")
    text.Size = UDim2.new(1, 0, 1, 0)
    text.BackgroundTransparency = 1
    text.Text = message
    text.TextColor3 = Settings.ChatTextColor
    text.TextSize = 16
    text.Font = Settings.ChatFont
    text.TextWrapped = true
    text.TextXAlignment = Enum.TextXAlignment.Left
    text.TextYAlignment = Enum.TextYAlignment.Top
    text.Parent = bubble
    
    -- Calculate text size for auto-sizing bubble
    local textBounds = text.TextBounds
    local bubbleWidth = math.clamp(textBounds.X + 24, 100, 300)
    local bubbleHeight = textBounds.Y + 16
    
    -- Animate bubble appearance (pop in)
    bubble.Size = UDim2.new(0, bubbleWidth, 0, 0)
    TweenService:Create(bubble, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = UDim2.new(0, bubbleWidth, 0, bubbleHeight)
    }):Play()
    
    -- Add small tail pointing to head (triangle)
    local tail = Instance.new("ImageLabel")
    tail.Size = UDim2.new(0, 14, 0, 8)
    tail.Position = UDim2.new(0.5, -7, 1, 0)
    tail.AnchorPoint = Vector2.new(0.5, 0)
    tail.BackgroundTransparency = 1
    tail.Image = "rbxasset://textures/ui/InGameMenu/Bubble.png"
    tail.ImageColor3 = Settings.ChatBubbleColor
    tail.ImageTransparency = Settings.ChatBubbleTransparency / 100
    tail.Parent = billboard
    
    -- Track bubble
    table.insert(activeChatBubbles, billboard)
    
    -- Auto-remove after duration
    task.delay(Settings.ChatBubbleDuration, function()
        -- Fade out animation
        TweenService:Create(bubble, TweenInfo.new(0.3), {
            BackgroundTransparency = 1
        }):Play()
        TweenService:Create(bubbleStroke, TweenInfo.new(0.3), {
            Transparency = 1
        }):Play()
        TweenService:Create(text, TweenInfo.new(0.3), {
            TextTransparency = 1
        }):Play()
        TweenService:Create(tail, TweenInfo.new(0.3), {
            ImageTransparency = 1
        }):Play()
        
        task.wait(0.3)
        billboard:Destroy()
        
        -- Remove from tracking
        for i, b in ipairs(activeChatBubbles) do
            if b == billboard then
                table.remove(activeChatBubbles, i)
                break
            end
        end
    end)
    
    -- Stack bubbles (move older ones up)
    local yOffset = 0
    for _, existingBubble in ipairs(activeChatBubbles) do
        if existingBubble ~= billboard and existingBubble.Parent then
            yOffset = yOffset + 0.8
            TweenService:Create(existingBubble, TweenInfo.new(0.2), {
                StudsOffset = Vector3.new(0, 3 + yOffset, 0)
            }):Play()
        end
    end
end

-- Create custom chat input GUI
local function CreateCustomChatBox()
    if not Settings.ChatBoxEnabled then return end
    
    -- Create ScreenGui
    customChatGui = Instance.new("ScreenGui")
    customChatGui.Name = "ZenithCustomChat"
    customChatGui.ResetOnSpawn = false
    customChatGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    customChatGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    
    -- Chat container (top-left)
    local chatContainer = Instance.new("Frame")
    chatContainer.Name = "ChatContainer"
    chatContainer.Size = UDim2.new(0, 350, 0, 300)
    chatContainer.Position = UDim2.new(0, 10, 0, 10)
    chatContainer.BackgroundTransparency = 1
    chatContainer.Parent = customChatGui
    
    -- Chat messages display (scrolling frame)
    local messagesFrame = Instance.new("ScrollingFrame")
    messagesFrame.Name = "MessagesFrame"
    messagesFrame.Size = UDim2.new(1, 0, 1, -50)
    messagesFrame.Position = UDim2.new(0, 0, 0, 0)
    messagesFrame.BackgroundTransparency = 0.3
    messagesFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    messagesFrame.BorderSizePixel = 0
    messagesFrame.ScrollBarThickness = 4
    messagesFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    messagesFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
    messagesFrame.Visible = false -- Hidden until chat is opened
    messagesFrame.Parent = chatContainer
    
    local messagesCorner = Instance.new("UICorner")
    messagesCorner.CornerRadius = UDim.new(0, 8)
    messagesCorner.Parent = messagesFrame
    
    local messagesLayout = Instance.new("UIListLayout")
    messagesLayout.Padding = UDim.new(0, 4)
    messagesLayout.SortOrder = Enum.SortOrder.LayoutOrder
    messagesLayout.Parent = messagesFrame
    
    local messagesPadding = Instance.new("UIPadding")
    messagesPadding.PaddingLeft = UDim.new(0, 8)
    messagesPadding.PaddingRight = UDim.new(0, 8)
    messagesPadding.PaddingTop = UDim.new(0, 8)
    messagesPadding.PaddingBottom = UDim.new(0, 8)
    messagesPadding.Parent = messagesFrame
    
    -- Input box container
    local inputContainer = Instance.new("Frame")
    inputContainer.Name = "InputContainer"
    inputContainer.Size = UDim2.new(1, 0, 0, 40)
    inputContainer.Position = UDim2.new(0, 0, 1, -45)
    inputContainer.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    inputContainer.BackgroundTransparency = 0.1
    inputContainer.BorderSizePixel = 0
    inputContainer.Visible = false -- Hidden until activated
    inputContainer.Parent = chatContainer
    
    local inputCorner = Instance.new("UICorner")
    inputCorner.CornerRadius = UDim.new(0, 8)
    inputCorner.Parent = inputContainer
    
    -- Chat input box
    chatInputBox = Instance.new("TextBox")
    chatInputBox.Name = "ChatInput"
    chatInputBox.Size = UDim2.new(1, -16, 1, -8)
    chatInputBox.Position = UDim2.new(0, 8, 0, 4)
    chatInputBox.BackgroundTransparency = 1
    chatInputBox.Text = ""
    chatInputBox.PlaceholderText = "Press / to chat..."
    chatInputBox.PlaceholderColor3 = Color3.fromRGB(178, 178, 178)
    chatInputBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    chatInputBox.TextSize = 16
    chatInputBox.Font = Enum.Font.Gotham
    chatInputBox.TextXAlignment = Enum.TextXAlignment.Left
    chatInputBox.ClearTextOnFocus = false
    chatInputBox.Parent = inputContainer
    
    -- Add message to display
    local messageCount = 0
    local function AddChatMessage(playerName, message, color)
        messageCount = messageCount + 1
        
        local msgLabel = Instance.new("TextLabel")
        msgLabel.Name = "Message_" .. messageCount
        msgLabel.Size = UDim2.new(1, 0, 0, 0)
        msgLabel.AutomaticSize = Enum.AutomaticSize.Y
        msgLabel.BackgroundTransparency = 1
        msgLabel.Text = string.format("[%s]: %s", playerName, message)
        msgLabel.TextColor3 = color or Color3.fromRGB(255, 255, 255)
        msgLabel.TextSize = 14
        msgLabel.Font = Enum.Font.Gotham
        msgLabel.TextXAlignment = Enum.TextXAlignment.Left
        msgLabel.TextWrapped = true
        msgLabel.LayoutOrder = messageCount
        msgLabel.Parent = messagesFrame
        
        -- Auto-scroll to bottom
        messagesFrame.CanvasPosition = Vector2.new(0, messagesFrame.AbsoluteCanvasSize.Y)
        
        -- Fade out old messages
        task.delay(30, function()
            if msgLabel then
                TweenService:Create(msgLabel, TweenInfo.new(1), {
                    TextTransparency = 1
                }):Play()
                task.wait(1)
                msgLabel:Destroy()
            end
        end)
    end
    
    -- Handle chat input
    chatInputBox.FocusLost:Connect(function(enterPressed)
        if enterPressed and chatInputBox.Text ~= "" then
            local message = chatInputBox.Text
            
            -- Apply bypass if enabled
            if Settings.ChatBypass then
                message = BypassText(message)
            end
            
            -- Create 3D chat bubble
            local char = GetChar()
            if char then
                CreateChatBubble(char, message)
            end
            
            -- Add to chat box
            AddChatMessage(LocalPlayer.Name, message, Settings.UIAccentColor)
            
            chatInputBox.Text = ""
        end
        
        -- Hide chat UI
        inputContainer.Visible = false
        task.wait(3)
        messagesFrame.Visible = false
    end)
    
    -- Open chat with "/"
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == Enum.KeyCode.Slash then
            if Settings.CustomChat and Settings.ChatBoxEnabled then
                messagesFrame.Visible = true
                inputContainer.Visible = true
                chatInputBox:CaptureFocus()
                chatInputBox.Text = ""
            end
        end
    end)
    
    print("âœ“ Custom Chat System Initialized")
end

-- Initialize custom chat
if Settings.ChatBoxEnabled then
    task.spawn(CreateCustomChatBox)
end

local function StopAutoWalk()
    if autoWalkConnection then
        autoWalkConnection:Disconnect()
        autoWalkConnection = nil
    end
    
    local char = GetChar()
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    if hum then
        hum:MoveTo(GetHRP().Position)
        hum.WalkSpeed = 16
    end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                       GHOST MODE SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--[[
    Desyncs character for scouting. Others see you standing still
    while you explore the map invisibly.
]]

local function EnableGhostMode()
    local char = GetChar()
    local hrp = GetHRP()
    if not (char and hrp) then return end
    
    -- Save original position
    ghostOriginalPosition = hrp.CFrame
    
    -- Create invisible clone at original position
    ghostClone = Instance.new("Part")
    ghostClone.Size = Vector3.new(2, 2, 1)
    ghostClone.Transparency = 1
    ghostClone.Anchored = true
    ghostClone.CanCollide = false
    ghostClone.CFrame = ghostOriginalPosition
    ghostClone.Parent = workspace
    
    -- Hide character from network (appears stationary to others)
    char.Parent = nil
    
    ghostActive = true
    print("âœ“ Ghost Mode: Active (You're invisible, use carefully)")
end

local function DisableGhostMode()
    local char = GetChar()
    local hrp = GetHRP()
    
    if ghostClone then
        ghostClone:Destroy()
        ghostClone = nil
    end
    
    -- Restore character
    if char then
        char.Parent = workspace
        
        -- Return to original position
        if ghostOriginalPosition and hrp then
            hrp.CFrame = ghostOriginalPosition
        end
    end
    
    ghostActive = false
    ghostOriginalPosition = nil
    print("âœ“ Ghost Mode: Disabled (Re-synced)")
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    REMOTE EVENT LOGGER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--[[
    Hooks namecall to intercept FireServer calls.
    Only logs when you interact with objects (smart filtering).
]]

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
    local method = getnamecallmethod()
    local args = {...}
    
    if Settings.RemoteLogger and method == "FireServer" or method == "InvokeServer" then
        local currentTime = tick()
        
        -- Smart filter: Only log if recent click or not using click filter
        if not Settings.LogOnlyClicks or (currentTime - lastClickTime < CLICK_WINDOW) then
            local remoteName = self.Name
            local remotePath = self:GetFullName()
            
            table.insert(remoteLog, {
                Time = os.date("%H:%M:%S"),
                Name = remoteName,
                Path = remotePath,
                Method = method,
                Args = args
            })
            
            -- Keep only last 50 entries
            if #remoteLog > 50 then
                table.remove(remoteLog, 1)
            end
            
            print("[REMOTE] " .. method .. " â†’ " .. remoteName)
        end
    end
    
    return oldNamecall(self, ...)
end)

-- Track clicks for smart filtering
table.insert(connections, UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        lastClickTime = tick()
    end
end))

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                       CHAT LOGGER SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

--[[
    Logs all chat messages including whispers and team chat.
    Works with default Roblox chat system.
]]

local TextChatService = game:GetService("TextChatService")
local StarterGui = game:GetService("StarterGui")

-- Try TextChatService (new chat)
pcall(function()
    TextChatService.MessageReceived:Connect(function(message)
        if Settings.ChatLogger then
            local speaker = message.TextSource and message.TextSource.Name or "Unknown"
            local text = message.Text
            
            table.insert(chatLog, {
                Time = os.date("%H:%M:%S"),
                Speaker = speaker,
                Message = text,
                Channel = "General"
            })
            
            print(string.format("[CHAT] %s: %s", speaker, text))
        end
    end)
end)

-- Fallback to legacy chat
local function SetupLegacyChat()
    local Players = game:GetService("Players")
    
    for _, player in ipairs(Players:GetPlayers()) do
        player.Chatted:Connect(function(msg)
            if Settings.ChatLogger then
                table.insert(chatLog, {
                    Time = os.date("%H:%M:%S"),
                    Speaker = player.Name,
                    Message = msg,
                    Channel = "General"
                })
                
                print(string.format("[CHAT] %s: %s", player.Name, msg))
            end
        end)
    end
    
    Players.PlayerAdded:Connect(function(player)
        player.Chatted:Connect(function(msg)
            if Settings.ChatLogger then
                table.insert(chatLog, {
                    Time = os.date("%H:%M:%S"),
                    Speaker = player.Name,
                    Message = msg,
                    Channel = "General"
                })
                
                print(string.format("[CHAT] %s: %s", player.Name, msg))
            end
        end)
    end)
end

pcall(SetupLegacyChat)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    CHAT BYPASS TRANSFORMER
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local bypassMap = {
    ["a"] = "Ğ°", ["e"] = "Ğµ", ["o"] = "Ğ¾", ["p"] = "Ñ€",
    ["c"] = "Ñ", ["y"] = "Ñƒ", ["x"] = "Ñ…", ["s"] = "Ñ•",
    ["i"] = "Ñ–", ["j"] = "Ñ˜", ["A"] = "Ğ", ["B"] = "Ğ’",
    ["E"] = "Ğ•", ["K"] = "Ğš", ["M"] = "Ğœ", ["H"] = "Ğ",
    ["O"] = "Ğ", ["P"] = "Ğ ", ["C"] = "Ğ¡", ["T"] = "Ğ¢",
    ["X"] = "Ğ¥", ["Y"] = "Ğ£"
}

local function BypassText(text)
    local result = ""
    for i = 1, #text do
        local char = text:sub(i, i)
        -- Randomly bypass some characters
        if bypassMap[char] and SmoothNoise(i * tick()) > 0.5 then
            result = result .. bypassMap[char]
        else
            result = result .. char
        end
    end
    return result
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    INVENTORY SCANNER SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function ScanPlayerInventory(player)
    local inventory = {}
    
    -- Check backpack
    if player.Backpack then
        for _, tool in ipairs(player.Backpack:GetChildren()) do
            if tool:IsA("Tool") then
                table.insert(inventory, {
                    Name = tool.Name,
                    Location = "Backpack"
                })
            end
        end
    end
    
    -- Check character
    if player.Character then
        for _, tool in ipairs(player.Character:GetChildren()) do
            if tool:IsA("Tool") then
                table.insert(inventory, {
                    Name = tool.Name,
                    Location = "Equipped"
                })
            end
        end
    end
    
    return inventory
end

local function ScanAllInventories()
    local results = {}
    
    for _, player in ipairs(Players:GetPlayers()) do
        local inventory = ScanPlayerInventory(player)
        if #inventory > 0 then
            results[player.Name] = inventory
        end
    end
    
    return results
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                        STAFF DETECTION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function IsStaff(player)
    local success, result = pcall(function()
        if game.CreatorType == Enum.CreatorType.Group then
            return player:GetRankInGroup(game.CreatorId) > 1
        else
            return player.UserId == game.CreatorId
        end
    end)
    return success and result
end

local function EmergencyShutdown(staffName)
    Settings.Flight = false
    Settings.Noclip = false
    warn("âš ï¸ STAFF DETECTED: " .. staffName .. " | Emergency Shutdown Active")
    
    -- Restore character immediately
    local char = GetChar()
    if char then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            hum:ChangeState(Enum.HumanoidStateType.GettingUp)
        end
        for _, part in ipairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
end

-- Check existing players on startup
if Settings.StaffCheck then
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and IsStaff(player) then
            EmergencyShutdown(player.Name)
            break
        end
    end
end

-- Monitor new players joining
table.insert(connections, Players.PlayerAdded:Connect(function(player)
    if Settings.StaffCheck and IsStaff(player) then
        EmergencyShutdown(player.Name)
    end
end))

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                     OPTIMIZED NOCLIP SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function CacheCharacterParts()
    cachedParts = {}
    local char = GetChar()
    if not char then return end
    
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            table.insert(cachedParts, part)
        end
    end
end

-- Recache when character changes
table.insert(connections, LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.5) -- Wait for character to fully load
    CacheCharacterParts()
end))

-- Initial cache
if GetChar() then
    CacheCharacterParts()
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                      FLIGHT & NOCLIP CORE
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- FLIGHT SYSTEM (PreRender for smooth 60+ FPS)
local flyConn = RunService.PreRender:Connect(function(deltaTime)
    local hrp = GetHRP()
    local char = GetChar()
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    
    if not (hrp and hum) then return end

    if Settings.Flight then
        -- Get input direction
        local moveDir = hum.MoveDirection
        local up = UserInputService:IsKeyDown(Enum.KeyCode.Space) and 1 or 0
        local down = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) and -1 or 0
        local verticalDir = Vector3.new(0, up + down, 0)
        
        local combinedDir = moveDir + verticalDir
        local targetCFrame = hrp.CFrame
        
        -- Calculate base target position
        if combinedDir.Magnitude > 0 then
            local targetPos = hrp.Position + (combinedDir.Unit * Settings.Speed * deltaTime)
            targetCFrame = CFrame.new(targetPos, targetPos + hrp.CFrame.LookVector)
        end
        
        -- Add humanization (natural drift and micro-adjustments)
        if Settings.FlightHumanization then
            local time = tick()
            
            -- Continuous smooth drift
            local drift = GetHumanizedOffset(time)
            targetCFrame = targetCFrame + drift
            
            -- Random micro-adjustments (simulates human reaction time)
            if time - lastMicroAdjust > Settings.MicroAdjustmentInterval then
                lastMicroAdjust = time
                
                -- Small random speed variance (90%-110% of target speed)
                local speedVariance = 0.9 + (SmoothNoise(time * 2) * 0.2)
                Settings.LerpWeight = Clamp(0.15 * speedVariance, 0.12, 0.18)
                
                -- Occasional slight direction adjustments
                if SmoothNoise(time * 3) > 0.7 then
                    local microTurn = CFrame.Angles(
                        (SmoothNoise(time * 4) - 0.5) * 0.05,
                        (SmoothNoise(time * 5) - 0.5) * 0.05,
                        0
                    )
                    targetCFrame = targetCFrame * microTurn
                end
            end
        end
        
        -- Smooth interpolation (frame-rate independent)
        local alpha = Clamp(Settings.LerpWeight * (deltaTime * 60), 0, 1)
        hrp.CFrame = hrp.CFrame:Lerp(targetCFrame, alpha)
        
        -- Mimic realistic physics (gradual velocity reduction instead of instant zero)
        local currentVel = hrp.AssemblyLinearVelocity
        local targetVel = Vector3.zero
        
        -- If moving, allow some velocity for realism
        if combinedDir.Magnitude > 0 then
            targetVel = combinedDir.Unit * (Settings.Speed * 0.3)
        end
        
        -- Smooth velocity transition (prevents instant stops/starts)
        hrp.AssemblyLinearVelocity = currentVel:Lerp(targetVel, 0.3)
        
        -- Apply fake lag if enabled
        UpdateFakeLag()
        
        -- Maintain physics-neutral state
        if hum:GetState() ~= Enum.HumanoidStateType.Physics then
            hum:ChangeState(Enum.HumanoidStateType.Physics)
        end
    end
end)
table.insert(connections, flyConn)

-- NOCLIP SYSTEM (Stepped for pre-physics execution)
local noclipConn = RunService.Stepped:Connect(function()
    if Settings.Noclip then
        if Settings.SelectiveNoclip then
            -- SELECTIVE MODE: Only noclip objects directly in front
            local objectsInFront = GetObjectsInFront()
            
            -- Re-enable all collisions first
            for _, part in ipairs(cachedParts) do
                if part and part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
            
            -- Only disable collision for objects we're walking into
            for _, obj in ipairs(objectsInFront) do
                if obj and obj:IsA("BasePart") then
                    obj.CanCollide = false
                    
                    -- Re-enable after passing through
                    task.delay(0.5, function()
                        if obj then
                            obj.CanCollide = true
                        end
                    end)
                end
            end
        else
            -- FULL MODE: Classic noclip (less realistic)
            for _, part in ipairs(cachedParts) do
                if part and part:IsA("BasePart") and part.CanCollide then
                    part.CanCollide = false
                end
            end
        end
    end
end)
table.insert(connections, noclipConn)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    STEALTHY ESP SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local CoreGui = game:GetService("CoreGui")

-- Wallcheck: Raycast to determine if player is visible
local function IsPlayerVisible(fromPos, toChar)
    if not Settings.ESPWallCheck then
        return true -- Skip wallcheck if disabled
    end
    
    local toHRP = toChar:FindFirstChild("HumanoidRootPart")
    if not toHRP then return false end
    
    local direction = (toHRP.Position - fromPos)
    local distance = direction.Magnitude
    
    -- Create raycast params
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    -- Ignore both characters and their accessories
    local ignoreList = {}
    table.insert(ignoreList, GetChar())
    table.insert(ignoreList, toChar)
    
    -- Also ignore accessories/tools
    for _, obj in ipairs(GetChar():GetDescendants()) do
        if obj:IsA("Accessory") or obj:IsA("Tool") then
            table.insert(ignoreList, obj)
        end
    end
    for _, obj in ipairs(toChar:GetDescendants()) do
        if obj:IsA("Accessory") or obj:IsA("Tool") then
            table.insert(ignoreList, obj)
        end
    end
    
    rayParams.FilterDescendantsInstances = ignoreList
    
    -- Perform raycast
    local result = workspace:Raycast(fromPos, direction.Unit * distance, rayParams)
    
    -- If raycast hit nothing or hit the target player, they're visible
    return result == nil or result.Instance:IsDescendantOf(toChar)
end

-- Create ESP for a single limb/part
local function CreateLimbBox(part, parent)
    local box = Drawing.new("Square")
    box.Visible = false
    box.Color = Settings.ESPBoxColor
    box.Thickness = 1
    box.Transparency = Settings.ESPBoxTransparency
    box.Filled = false
    
    return box
end

-- Create full ESP for a player
local function CreateESP(player)
    if player == LocalPlayer then return end
    if espObjects[player] then return end
    
    local espData = {
        Boxes = {},
        NameLabel = nil,
        DistanceLabel = nil,
    }
    
    -- Create name label (Drawing API for performance)
    local nameLabel = Drawing.new("Text")
    nameLabel.Visible = false
    nameLabel.Color = Settings.ESPTextColor
    nameLabel.Size = 16
    nameLabel.Center = true
    nameLabel.Outline = true
    nameLabel.Font = 2
    nameLabel.Text = player.Name
    espData.NameLabel = nameLabel
    
    -- Create distance label
    local distLabel = Drawing.new("Text")
    distLabel.Visible = false
    distLabel.Color = Settings.ESPTextColor
    distLabel.Size = 14
    distLabel.Center = true
    distLabel.Outline = true
    distLabel.Font = 2
    espData.DistanceLabel = distLabel
    
    espObjects[player] = espData
end

-- Remove ESP for a player
local function RemoveESP(player)
    local espData = espObjects[player]
    if not espData then return end
    
    -- Cleanup boxes
    for _, box in pairs(espData.Boxes) do
        if box then
            box:Remove()
        end
    end
    
    -- Cleanup labels
    if espData.NameLabel then espData.NameLabel:Remove() end
    if espData.DistanceLabel then espData.DistanceLabel:Remove() end
    
    espObjects[player] = nil
end

-- Update ESP for all players
local function UpdateESP()
    -- Hide ESP in streamer mode
    if not Settings.ESP or Settings.StreamerMode then
        -- Hide all ESP when disabled or in streamer mode
        for _, espData in pairs(espObjects) do
            if espData.NameLabel then espData.NameLabel.Visible = false end
            if espData.DistanceLabel then espData.DistanceLabel.Visible = false end
            for _, box in pairs(espData.Boxes) do
                if box then box.Visible = false end
            end
        end
        return
    end
    
    local camera = workspace.CurrentCamera
    local myChar = GetChar()
    local myHRP = GetHRP()
    if not (camera and myHRP) then return end
    
    for player, espData in pairs(espObjects) do
        if not player or not player.Parent then
            RemoveESP(player)
            continue
        end
        
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        
        if not (char and hrp) then
            -- Hide if no character
            if espData.NameLabel then espData.NameLabel.Visible = false end
            if espData.DistanceLabel then espData.DistanceLabel.Visible = false end
            for _, box in pairs(espData.Boxes) do
                if box then box.Visible = false end
            end
            continue
        end
        
        -- Calculate distance
        local distance = (myHRP.Position - hrp.Position).Magnitude
        
        -- Check max distance
        if distance > Settings.ESPMaxDistance then
            if espData.NameLabel then espData.NameLabel.Visible = false end
            if espData.DistanceLabel then espData.DistanceLabel.Visible = false end
            for _, box in pairs(espData.Boxes) do
                if box then box.Visible = false end
            end
            continue
        end
        
        -- WALLCHECK: Only show if visible (when enabled)
        local isVisible = true
        if Settings.ESPVisibilityMode == "VisibleOnly" then
            isVisible = IsPlayerVisible(myHRP.Position, char)
        end
        
        if not isVisible then
            if espData.NameLabel then espData.NameLabel.Visible = false end
            if espData.DistanceLabel then espData.DistanceLabel.Visible = false end
            for _, box in pairs(espData.Boxes) do
                if box then box.Visible = false end
            end
            continue
        end
        
        -- Get head position for labels
        local head = char:FindFirstChild("Head")
        if head then
            local headPos, onScreen = camera:WorldToViewportPoint(head.Position + Vector3.new(0, 1.5, 0))
            
            if onScreen then
                -- Update name label
                espData.NameLabel.Position = Vector2.new(headPos.X, headPos.Y)
                espData.NameLabel.Visible = true
                
                -- Update distance label
                espData.DistanceLabel.Position = Vector2.new(headPos.X, headPos.Y + 18)
                espData.DistanceLabel.Text = string.format("[%d studs]", math.floor(distance))
                espData.DistanceLabel.Visible = true
            else
                espData.NameLabel.Visible = false
                espData.DistanceLabel.Visible = false
            end
        end
        
        -- Draw boxes on limbs
        local limbs = {"Head", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg",
                       "UpperTorso", "LowerTorso", "LeftUpperArm", "LeftLowerArm", "LeftHand",
                       "RightUpperArm", "RightLowerArm", "RightHand", "LeftUpperLeg", 
                       "LeftLowerLeg", "LeftFoot", "RightUpperLeg", "RightLowerLeg", "RightFoot"}
        
        local boxIndex = 1
        for _, limbName in ipairs(limbs) do
            local limb = char:FindFirstChild(limbName)
            
            if limb and limb:IsA("BasePart") then
                -- Create box if doesn't exist
                if not espData.Boxes[boxIndex] then
                    espData.Boxes[boxIndex] = CreateLimbBox(limb)
                end
                
                local box = espData.Boxes[boxIndex]
                
                -- Calculate 2D bounding box from 3D part
                local cf = limb.CFrame
                local size = limb.Size
                
                -- Get 8 corners of the part
                local corners = {
                    cf * CFrame.new(-size.X/2, -size.Y/2, -size.Z/2),
                    cf * CFrame.new(size.X/2, -size.Y/2, -size.Z/2),
                    cf * CFrame.new(-size.X/2, size.Y/2, -size.Z/2),
                    cf * CFrame.new(size.X/2, size.Y/2, -size.Z/2),
                    cf * CFrame.new(-size.X/2, -size.Y/2, size.Z/2),
                    cf * CFrame.new(size.X/2, -size.Y/2, size.Z/2),
                    cf * CFrame.new(-size.X/2, size.Y/2, size.Z/2),
                    cf * CFrame.new(size.X/2, size.Y/2, size.Z/2),
                }
                
                -- Project to screen space and find min/max
                local minX, minY = math.huge, math.huge
                local maxX, maxY = -math.huge, -math.huge
                local anyOnScreen = false
                
                for _, corner in ipairs(corners) do
                    local screenPos, onScreen = camera:WorldToViewportPoint(corner.Position)
                    if onScreen then
                        anyOnScreen = true
                        minX = math.min(minX, screenPos.X)
                        minY = math.min(minY, screenPos.Y)
                        maxX = math.max(maxX, screenPos.X)
                        maxY = math.max(maxY, screenPos.Y)
                    end
                end
                
                -- Update box if on screen
                if anyOnScreen and minX ~= math.huge then
                    box.Position = Vector2.new(minX, minY)
                    box.Size = Vector2.new(maxX - minX, maxY - minY)
                    box.Visible = true
                else
                    box.Visible = false
                end
                
                boxIndex = boxIndex + 1
            end
        end
        
        -- Hide unused boxes
        for i = boxIndex, #espData.Boxes do
            if espData.Boxes[i] then
                espData.Boxes[i].Visible = false
            end
        end
    end
end

-- Initialize ESP for existing players
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        CreateESP(player)
    end
end

-- Handle new players
table.insert(connections, Players.PlayerAdded:Connect(function(player)
    CreateESP(player)
end))

-- Handle players leaving
table.insert(connections, Players.PlayerRemoving:Connect(function(player)
    RemoveESP(player)
end))

-- Update ESP every frame (RenderStepped for smooth visuals)
local espUpdateConn = RunService.RenderStepped:Connect(function()
    UpdateESP()
end)
table.insert(connections, espUpdateConn)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                    MODERN TABBED UI SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local currentTab = "Main"
local uiElements = {} -- Store references for live updating

local function CreateUI()
    -- Create ScreenGui
    gui = Instance.new("ScreenGui")
    gui.Name = "ZenithUI"
    gui.ResetOnSpawn = false
    gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Parent to CoreGui if streamer mode (hidden from most recording software)
    if Settings.StreamerMode then
        gui.Parent = game:GetService("CoreGui")
    else
        gui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    end
    
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TOGGLE BUTTON (Mobile & PC) â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    local toggleButton = Instance.new("ImageButton")
    toggleButton.Name = "ZenithToggle"
    toggleButton.Size = UDim2.new(0, 60, 0, 60)
    toggleButton.Position = UDim2.new(1, -70, 1, -70) -- Bottom-right corner
    toggleButton.AnchorPoint = Vector2.new(0, 0)
    toggleButton.BackgroundColor3 = Settings.UIAccentColor
    toggleButton.BorderSizePixel = 0
    toggleButton.Image = "" -- No image, using text icon
    toggleButton.Parent = gui
    
    -- Make it circular
    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(1, 0) -- Full circle
    toggleCorner.Parent = toggleButton
    
    -- Add glow effect
    local toggleStroke = Instance.new("UIStroke")
    toggleStroke.Color = Color3.fromRGB(255, 255, 255)
    toggleStroke.Thickness = 2
    toggleStroke.Transparency = 0.5
    toggleStroke.Parent = toggleButton
    
    -- Icon text (Z for Zenith)
    local toggleIcon = Instance.new("TextLabel")
    toggleIcon.Size = UDim2.new(1, 0, 1, 0)
    toggleIcon.BackgroundTransparency = 1
    toggleIcon.Text = "Z"
    toggleIcon.TextColor3 = Color3.fromRGB(255, 255, 255)
    toggleIcon.TextSize = 32
    toggleIcon.Font = Enum.Font.GothamBold
    toggleIcon.Parent = toggleButton
    
    -- Pulse animation for toggle button
    local function PulseButton()
        local tween = TweenService:Create(toggleButton, TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
            Size = UDim2.new(0, 65, 0, 65)
        })
        tween:Play()
    end
    
    if isMobileDevice then
        PulseButton() -- Pulse on mobile to draw attention
    end
    
    -- Main Container (starts hidden if minimized)
    local mainContainer = Instance.new("Frame")
    mainContainer.Name = "MainContainer"
    
    -- Position based on device
    if isMobileDevice then
        mainContainer.Size = UDim2.new(0, 340, 0, 500) -- Smaller for mobile
        mainContainer.Position = UDim2.new(0.5, -170, 0.5, -250)
    else
        mainContainer.Size = UDim2.new(0, 400, 0, 320)
        mainContainer.Position = UDim2.new(0.02, 0, 0.5, -160)
    end
    
    mainContainer.BackgroundColor3 = Settings.UIBackgroundColor
    mainContainer.BackgroundTransparency = Settings.UITransparency
    mainContainer.BorderSizePixel = 0
    mainContainer.Visible = not Settings.UIMinimized -- Start hidden if minimized
    mainContainer.Parent = gui
    uiElements.MainContainer = mainContainer
    
    local containerCorner = Instance.new("UICorner")
    containerCorner.CornerRadius = UDim.new(0, Settings.UICornerRadius)
    containerCorner.Parent = mainContainer
    uiElements.ContainerCorner = containerCorner
    
    -- Glow/Stroke effect
    local containerStroke = Instance.new("UIStroke")
    containerStroke.Color = Settings.UIAccentColor
    containerStroke.Thickness = 1
    containerStroke.Transparency = Settings.UIGlowEnabled and 0.5 or 1
    containerStroke.Parent = mainContainer
    uiElements.ContainerStroke = containerStroke
    
    -- Title Bar
    local titleBar = Instance.new("Frame")
    titleBar.Size = UDim2.new(1, 0, 0, 40)
    titleBar.BackgroundColor3 = Color3.fromRGB(
        Settings.UIBackgroundColor.R * 255 * 1.5,
        Settings.UIBackgroundColor.G * 255 * 1.5,
        Settings.UIBackgroundColor.B * 255 * 1.5
    )
    titleBar.BackgroundTransparency = Settings.UITransparency
    titleBar.BorderSizePixel = 0
    titleBar.Parent = mainContainer
    uiElements.TitleBar = titleBar
    
    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, Settings.UICornerRadius)
    titleCorner.Parent = titleBar
    
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, -80, 1, 0)
    title.Position = UDim2.new(0, 10, 0, 0)
    title.BackgroundTransparency = 1
    title.Text = "ZENITH V17"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.TextSize = 18
    title.Font = Settings.UITitleFont
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.Parent = titleBar
    uiElements.Title = title
    
    -- Minimize button
    local minimizeBtn = Instance.new("TextButton")
    minimizeBtn.Size = UDim2.new(0, 30, 0, 30)
    minimizeBtn.Position = UDim2.new(1, -70, 0, 5)
    minimizeBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 255)
    minimizeBtn.Text = "âˆ’"
    minimizeBtn.TextColor3 = Color3.white
    minimizeBtn.TextSize = 20
    minimizeBtn.Font = Enum.Font.GothamBold
    minimizeBtn.Parent = titleBar
    
    local minimizeBtnCorner = Instance.new("UICorner")
    minimizeBtnCorner.CornerRadius = UDim.new(0, 6)
    minimizeBtnCorner.Parent = minimizeBtn
    
    -- Close button
    local closeBtn = Instance.new("TextButton")
    closeBtn.Size = UDim2.new(0, 30, 0, 30)
    closeBtn.Position = UDim2.new(1, -35, 0, 5)
    closeBtn.BackgroundColor3 = Color3.fromRGB(255, 60, 60)
    closeBtn.Text = "Ã—"
    closeBtn.TextColor3 = Color3.white
    closeBtn.TextSize = 20
    closeBtn.Font = Enum.Font.GothamBold
    closeBtn.Parent = titleBar
    
    local closeBtnCorner = Instance.new("UICorner")
    closeBtnCorner.CornerRadius = UDim.new(0, 6)
    closeBtnCorner.Parent = closeBtn
    
    -- Toggle button click handler
    toggleButton.MouseButton1Click:Connect(function()
        Settings.UIMinimized = not Settings.UIMinimized
        mainContainer.Visible = not Settings.UIMinimized
        
        -- Animate toggle button
        local targetSize = Settings.UIMinimized and UDim2.new(0, 60, 0, 60) or UDim2.new(0, 50, 0, 50)
        TweenService:Create(toggleButton, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
            Size = targetSize,
            Rotation = Settings.UIMinimized and 0 or 90
        }):Play()
        
        -- Animate main container
        if not Settings.UIMinimized then
            mainContainer.Size = UDim2.new(0, 0, 0, 0)
            mainContainer.Visible = true
            
            local targetSize = isMobileDevice and UDim2.new(0, 340, 0, 500) or UDim2.new(0, 400, 0, 320)
            TweenService:Create(mainContainer, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
                Size = targetSize
            }):Play()
        else
            TweenService:Create(mainContainer, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {
                Size = UDim2.new(0, 0, 0, 0)
            }):Play()
            
            task.wait(0.2)
            mainContainer.Visible = false
        end
    end)
    
    -- Minimize button handler
    minimizeBtn.MouseButton1Click:Connect(function()
        Settings.UIMinimized = true
        mainContainer.Visible = false
        
        -- Animate toggle button back
        TweenService:Create(toggleButton, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
            Size = UDim2.new(0, 60, 0, 60),
            Rotation = 0
        }):Play()
    end)
    
    closeBtn.MouseButton1Click:Connect(function()
        gui.Enabled = false
    end)
    
    -- Tab Container
    local tabContainer = Instance.new("Frame")
    tabContainer.Size = UDim2.new(1, -20, 0, 35)
    tabContainer.Position = UDim2.new(0, 10, 0, 50)
    tabContainer.BackgroundTransparency = 1
    tabContainer.Parent = mainContainer
    
    local tabLayout = Instance.new("UIListLayout")
    tabLayout.FillDirection = Enum.FillDirection.Horizontal
    tabLayout.Padding = UDim.new(0, 8)
    tabLayout.Parent = tabContainer
    
    -- Tab Buttons
    local tabs = {"Main", "Customize", "Tools", "Logs"}
    local tabButtons = {}
    
    local function UpdateTabVisuals()
        for tabName, btn in pairs(tabButtons) do
            if tabName == currentTab then
                btn.BackgroundColor3 = Settings.UIAccentColor
                btn.TextColor3 = Color3.white
            else
                btn.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
                btn.TextColor3 = Color3.fromRGB(180, 180, 180)
            end
        end
    end
    
    for _, tabName in ipairs(tabs) do
        local tabBtn = Instance.new("TextButton")
        tabBtn.Size = UDim2.new(0, 70, 1, 0)
        tabBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
        tabBtn.Text = tabName
        tabBtn.TextColor3 = Color3.fromRGB(180, 180, 180)
        tabBtn.TextSize = 13
        tabBtn.Font = Settings.UIFont
        tabBtn.Parent = tabContainer
        
        local tabBtnCorner = Instance.new("UICorner")
        tabBtnCorner.CornerRadius = UDim.new(0, 6)
        tabBtnCorner.Parent = tabBtn
        
        tabButtons[tabName] = tabBtn
        
        tabBtn.MouseButton1Click:Connect(function()
            currentTab = tabName
            UpdateTabVisuals()
            -- Show/hide content panels
            for _, child in ipairs(mainContainer:GetChildren()) do
                if child.Name:match("Panel") then
                    child.Visible = (child.Name == tabName .. "Panel")
                end
            end
        end)
    end
    
    UpdateTabVisuals()
    
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MAIN TAB PANEL â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    local mainPanel = Instance.new("Frame")
    mainPanel.Name = "MainPanel"
    mainPanel.Size = UDim2.new(1, -20, 1, -100)
    mainPanel.Position = UDim2.new(0, 10, 0, 95)
    mainPanel.BackgroundTransparency = 1
    mainPanel.Parent = mainContainer
    
    local mainLayout = Instance.new("UIListLayout")
    mainLayout.Padding = UDim.new(0, 10)
    mainLayout.SortOrder = Enum.SortOrder.LayoutOrder
    mainLayout.Parent = mainPanel
    
    -- Helper: Create status line
    local function CreateStatusLine(name, key, layoutOrder)
        local frame = Instance.new("Frame")
        frame.Size = UDim2.new(1, 0, 0, 28)
        frame.BackgroundTransparency = 1
        frame.LayoutOrder = layoutOrder
        frame.Parent = mainPanel
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(0.6, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.Text = name .. " [" .. key .. "]"
        label.TextColor3 = Color3.fromRGB(200, 200, 200)
        label.TextSize = 15
        label.Font = Settings.UIFont
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = frame
        uiElements[name .. "Label"] = label
        
        local status = Instance.new("TextLabel")
        status.Name = "Status"
        status.Size = UDim2.new(0.4, 0, 1, 0)
        status.Position = UDim2.new(0.6, 0, 0, 0)
        status.BackgroundTransparency = 1
        status.Text = "OFF"
        status.TextColor3 = Color3.fromRGB(255, 100, 100)
        status.TextSize = 15
        status.Font = Enum.Font.GothamBold
        status.TextXAlignment = Enum.TextXAlignment.Right
        status.Parent = frame
        
        return status
    end
    
    -- Status indicators
    local flightStatus = CreateStatusLine("Flight", "F", 1)
    local noclipStatus = CreateStatusLine("Noclip", "N", 2)
    local espStatus = CreateStatusLine("ESP", "E", 3)
    local speedStatus = CreateStatusLine("Speed", "+/-", 4)
    speedStatus.Text = tostring(Settings.Speed)
    speedStatus.TextColor3 = Settings.UIAccentColor
    
    -- ESP Visibility Mode Button
    local espModeContainer = Instance.new("Frame")
    espModeContainer.Size = UDim2.new(1, 0, 0, 30)
    espModeContainer.BackgroundTransparency = 1
    espModeContainer.LayoutOrder = 5
    espModeContainer.Parent = mainPanel
    
    local espModeLabel = Instance.new("TextLabel")
    espModeLabel.Size = UDim2.new(0.5, 0, 1, 0)
    espModeLabel.BackgroundTransparency = 1
    espModeLabel.Text = "ESP Mode:"
    espModeLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    espModeLabel.TextSize = 14
    espModeLabel.Font = Settings.UIFont
    espModeLabel.TextXAlignment = Enum.TextXAlignment.Left
    espModeLabel.Parent = espModeContainer
    
    local espModeBtn = Instance.new("TextButton")
    espModeBtn.Size = UDim2.new(0.5, 0, 0, 26)
    espModeBtn.Position = UDim2.new(0.5, 0, 0.5, -13)
    espModeBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    espModeBtn.Text = Settings.ESPVisibilityMode == "VisibleOnly" and "Visible Only" or "Always Show"
    espModeBtn.TextColor3 = Color3.white
    espModeBtn.TextSize = 12
    espModeBtn.Font = Enum.Font.GothamBold
    espModeBtn.Parent = espModeContainer
    
    local espModeBtnCorner = Instance.new("UICorner")
    espModeBtnCorner.CornerRadius = UDim.new(0, 6)
    espModeBtnCorner.Parent = espModeBtn
    
    espModeBtn.MouseButton1Click:Connect(function()
        -- Toggle between modes
        if Settings.ESPVisibilityMode == "VisibleOnly" then
            Settings.ESPVisibilityMode = "Always"
            espModeBtn.Text = "Always Show"
            espModeBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 255)
        else
            Settings.ESPVisibilityMode = "VisibleOnly"
            espModeBtn.Text = "Visible Only"
            espModeBtn.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        end
    end)
    
    uiElements.ESPModeBtn = espModeBtn
    
    uiElements.FlightStatus = flightStatus
    uiElements.NoclipStatus = noclipStatus
    uiElements.ESPStatus = espStatus
    uiElements.SpeedStatus = speedStatus
    
    -- Info text
    local infoText = Instance.new("TextLabel")
    infoText.Size = UDim2.new(1, 0, 0, 40)
    infoText.LayoutOrder = 6
    infoText.BackgroundTransparency = 1
    infoText.Text = "RCtrl - Toggle UI\nDrag title bar to move"
    infoText.TextColor3 = Color3.fromRGB(120, 120, 120)
    infoText.TextSize = 12
    infoText.Font = Settings.UIFont
    infoText.TextWrapped = true
    infoText.Parent = mainPanel
    uiElements.InfoText = infoText
    
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CUSTOMIZE TAB PANEL â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    local customizePanel = Instance.new("ScrollingFrame")
    customizePanel.Name = "CustomizePanel"
    customizePanel.Size = UDim2.new(1, -20, 1, -100)
    customizePanel.Position = UDim2.new(0, 10, 0, 95)
    customizePanel.BackgroundTransparency = 1
    customizePanel.BorderSizePixel = 0
    customizePanel.ScrollBarThickness = 4
    customizePanel.Visible = false
    customizePanel.Parent = mainContainer
    customizePanel.CanvasSize = UDim2.new(0, 0, 0, 600)
    
    local customizeLayout = Instance.new("UIListLayout")
    customizeLayout.Padding = UDim.new(0, 12)
    customizeLayout.SortOrder = Enum.SortOrder.LayoutOrder
    customizeLayout.Parent = customizePanel
    
    -- Helper: Create slider
    local function CreateSlider(name, min, max, current, callback, layoutOrder)
        local container = Instance.new("Frame")
        container.Size = UDim2.new(1, 0, 0, 50)
        container.BackgroundTransparency = 1
        container.LayoutOrder = layoutOrder
        container.Parent = customizePanel
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(1, 0, 0, 18)
        label.BackgroundTransparency = 1
        label.Text = name
        label.TextColor3 = Color3.fromRGB(220, 220, 220)
        label.TextSize = 14
        label.Font = Settings.UIFont
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = container
        
        local sliderBg = Instance.new("Frame")
        sliderBg.Size = UDim2.new(1, 0, 0, 6)
        sliderBg.Position = UDim2.new(0, 0, 0, 25)
        sliderBg.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
        sliderBg.BorderSizePixel = 0
        sliderBg.Parent = container
        
        local sliderBgCorner = Instance.new("UICorner")
        sliderBgCorner.CornerRadius = UDim.new(0, 3)
        sliderBgCorner.Parent = sliderBg
        
        local sliderFill = Instance.new("Frame")
        sliderFill.Size = UDim2.new((current - min) / (max - min), 0, 1, 0)
        sliderFill.BackgroundColor3 = Settings.UIAccentColor
        sliderFill.BorderSizePixel = 0
        sliderFill.Parent = sliderBg
        
        local sliderFillCorner = Instance.new("UICorner")
        sliderFillCorner.CornerRadius = UDim.new(0, 3)
        sliderFillCorner.Parent = sliderFill
        
        local valueLabel = Instance.new("TextLabel")
        valueLabel.Size = UDim2.new(0, 50, 0, 18)
        valueLabel.Position = UDim2.new(1, -50, 0, 0)
        valueLabel.BackgroundTransparency = 1
        valueLabel.Text = tostring(current)
        valueLabel.TextColor3 = Settings.UIAccentColor
        valueLabel.TextSize = 13
        valueLabel.Font = Enum.Font.GothamBold
        valueLabel.TextXAlignment = Enum.TextXAlignment.Right
        valueLabel.Parent = container
        
        local dragging = false
        
        sliderBg.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
            end
        end)
        
        sliderBg.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
            end
        end)
        
        UserInputService.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local relativeX = Clamp((input.Position.X - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X, 0, 1)
                local value = math.floor(min + (max - min) * relativeX)
                
                sliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
                valueLabel.Text = tostring(value)
                callback(value)
            end
        end)
    end
    
    -- Helper: Create color picker
    local function CreateColorPicker(name, current, callback, layoutOrder)
        local container = Instance.new("Frame")
        container.Size = UDim2.new(1, 0, 0, 40)
        container.BackgroundTransparency = 1
        container.LayoutOrder = layoutOrder
        container.Parent = customizePanel
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(0.7, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.Text = name
        label.TextColor3 = Color3.fromRGB(220, 220, 220)
        label.TextSize = 14
        label.Font = Settings.UIFont
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = container
        
        local colorDisplay = Instance.new("Frame")
        colorDisplay.Size = UDim2.new(0, 60, 0, 28)
        colorDisplay.Position = UDim2.new(1, -60, 0.5, -14)
        colorDisplay.BackgroundColor3 = current
        colorDisplay.BorderSizePixel = 0
        colorDisplay.Parent = container
        
        local colorCorner = Instance.new("UICorner")
        colorCorner.CornerRadius = UDim.new(0, 6)
        colorCorner.Parent = colorDisplay
        
        -- Simple color cycle on click
        colorDisplay.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                local colors = {
                    Color3.fromRGB(100, 100, 255), -- Blue
                    Color3.fromRGB(255, 100, 100), -- Red
                    Color3.fromRGB(100, 255, 100), -- Green
                    Color3.fromRGB(255, 255, 100), -- Yellow
                    Color3.fromRGB(255, 100, 255), -- Magenta
                    Color3.fromRGB(100, 255, 255), -- Cyan
                    Color3.fromRGB(255, 255, 255), -- White
                    Color3.fromRGB(20, 20, 25),    -- Dark
                }
                
                local currentIdx = 1
                for i, col in ipairs(colors) do
                    if col == colorDisplay.BackgroundColor3 then
                        currentIdx = i
                        break
                    end
                end
                
                local nextColor = colors[(currentIdx % #colors) + 1]
                colorDisplay.BackgroundColor3 = nextColor
                callback(nextColor)
            end
        end)
    end
    
    -- Helper: Create toggle
    local function CreateToggle(name, current, callback, layoutOrder)
        local container = Instance.new("Frame")
        container.Size = UDim2.new(1, 0, 0, 35)
        container.BackgroundTransparency = 1
        container.LayoutOrder = layoutOrder
        container.Parent = customizePanel
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(0.7, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.Text = name
        label.TextColor3 = Color3.fromRGB(220, 220, 220)
        label.TextSize = 14
        label.Font = Settings.UIFont
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = container
        
        local toggle = Instance.new("TextButton")
        toggle.Size = UDim2.new(0, 50, 0, 24)
        toggle.Position = UDim2.new(1, -50, 0.5, -12)
        toggle.BackgroundColor3 = current and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
        toggle.Text = current and "ON" or "OFF"
        toggle.TextColor3 = Color3.white
        toggle.TextSize = 12
        toggle.Font = Enum.Font.GothamBold
        toggle.Parent = container
        
        local toggleCorner = Instance.new("UICorner")
        toggleCorner.CornerRadius = UDim.new(0, 6)
        toggleCorner.Parent = toggle
        
        toggle.MouseButton1Click:Connect(function()
            current = not current
            toggle.BackgroundColor3 = current and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
            toggle.Text = current and "ON" or "OFF"
            callback(current)
        end)
    end
    
    -- Customization options
    CreateColorPicker("Background Color", Settings.UIBackgroundColor, function(col)
        Settings.UIBackgroundColor = col
        mainContainer.BackgroundColor3 = col
        titleBar.BackgroundColor3 = Color3.fromRGB(col.R * 255 * 1.5, col.G * 255 * 1.5, col.B * 255 * 1.5)
    end, 1)
    
    CreateColorPicker("Accent Color", Settings.UIAccentColor, function(col)
        Settings.UIAccentColor = col
        containerStroke.Color = col
        speedStatus.TextColor3 = col
        UpdateTabVisuals()
    end, 2)
    
    CreateSlider("Transparency", 0, 90, Settings.UITransparency * 100, function(val)
        Settings.UITransparency = val / 100
        mainContainer.BackgroundTransparency = Settings.UITransparency
        titleBar.BackgroundTransparency = Settings.UITransparency
    end, 3)
    
    CreateSlider("Corner Radius", 0, 25, Settings.UICornerRadius, function(val)
        Settings.UICornerRadius = val
        containerCorner.CornerRadius = UDim.new(0, val)
    end, 4)
    
    CreateToggle("Glow Effect", Settings.UIGlowEnabled, function(val)
        Settings.UIGlowEnabled = val
        containerStroke.Transparency = val and 0.5 or 1
    end, 5)
    
    -- Separator
    local separator1 = Instance.new("Frame")
    separator1.Size = UDim2.new(1, 0, 0, 2)
    separator1.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
    separator1.BorderSizePixel = 0
    separator1.LayoutOrder = 6
    separator1.Parent = customizePanel
    
    -- Advanced Features Section
    local advancedLabel = Instance.new("TextLabel")
    advancedLabel.Size = UDim2.new(1, 0, 0, 25)
    advancedLabel.BackgroundTransparency = 1
    advancedLabel.Text = "âš¡ ADVANCED FEATURES"
    advancedLabel.TextColor3 = Settings.UIAccentColor
    advancedLabel.TextSize = 14
    advancedLabel.Font = Enum.Font.GothamBold
    advancedLabel.TextXAlignment = Enum.TextXAlignment.Left
    advancedLabel.LayoutOrder = 7
    advancedLabel.Parent = customizePanel
    
    CreateToggle("Streamer Mode", Settings.StreamerMode, function(val)
        Settings.StreamerMode = val
        
        -- Move UI to CoreGui or back
        if val then
            gui.Parent = game:GetService("CoreGui")
            gui.Enabled = false -- Start hidden in streamer mode
        else
            gui.Parent = LocalPlayer:WaitForChild("PlayerGui")
            gui.Enabled = true
        end
        
        -- Force ESP update
        UpdateESP()
    end, 8)
    
    CreateToggle("Selective Noclip", Settings.SelectiveNoclip, function(val)
        Settings.SelectiveNoclip = val
    end, 9)
    
    CreateToggle("Fake Lag", Settings.FakeLag, function(val)
        Settings.FakeLag = val
        positionBuffer = {} -- Clear buffer on toggle
    end, 10)
    
    CreateSlider("Fake Lag Intensity", 10, 50, Settings.FakeLagIntensity * 100, function(val)
        Settings.FakeLagIntensity = val / 100
    end, 11)
    
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TOOLS TAB PANEL â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    local toolsPanel = Instance.new("ScrollingFrame")
    toolsPanel.Name = "ToolsPanel"
    toolsPanel.Size = UDim2.new(1, -20, 1, -100)
    toolsPanel.Position = UDim2.new(0, 10, 0, 95)
    toolsPanel.BackgroundTransparency = 1
    toolsPanel.BorderSizePixel = 0
    toolsPanel.ScrollBarThickness = 4
    toolsPanel.Visible = false
    toolsPanel.Parent = mainContainer
    toolsPanel.CanvasSize = UDim2.new(0, 0, 0, 1000) -- Increased for chat options
    
    local toolsLayout = Instance.new("UIListLayout")
    toolsLayout.Padding = UDim.new(0, 10)
    toolsLayout.SortOrder = Enum.SortOrder.LayoutOrder
    toolsLayout.Parent = toolsPanel
    
    -- Helper: Create action button
    local function CreateActionButton(name, description, callback, layoutOrder)
        local container = Instance.new("Frame")
        container.Size = UDim2.new(1, 0, 0, 60)
        container.BackgroundTransparency = 1
        container.LayoutOrder = layoutOrder
        container.Parent = toolsPanel
        
        local btn = Instance.new("TextButton")
        btn.Size = UDim2.new(1, 0, 0, 35)
        btn.BackgroundColor3 = Settings.UIAccentColor
        btn.Text = name
        btn.TextColor3 = Color3.white
        btn.TextSize = 14
        btn.Font = Enum.Font.GothamBold
        btn.Parent = container
        
        local btnCorner = Instance.new("UICorner")
        btnCorner.CornerRadius = UDim.new(0, 8)
        btnCorner.Parent = btn
        
        local desc = Instance.new("TextLabel")
        desc.Size = UDim2.new(1, 0, 0, 18)
        desc.Position = UDim2.new(0, 0, 0, 40)
        desc.BackgroundTransparency = 1
        desc.Text = description
        desc.TextColor3 = Color3.fromRGB(150, 150, 150)
        desc.TextSize = 11
        desc.Font = Settings.UIFont
        desc.TextWrapped = true
        desc.Parent = container
        
        btn.MouseButton1Click:Connect(callback)
        
        return btn
    end
    
    -- Auto-Walk Tool
    CreateToggle("Auto-Walk", Settings.AutoWalk, function(val)
        Settings.AutoWalk = val
        if not val then
            StopAutoWalk()
        end
    end, 1)
    
    CreateActionButton("Set Walk Target (Click Mouse)", "Left-click anywhere to pathfind there", function()
        local mouse = LocalPlayer:GetMouse()
        mouse.Button1Down:Connect(function()
            if Settings.AutoWalk and mouse.Target then
                StartAutoWalk(mouse.Hit.Position)
            end
        end)
        print("âœ“ Click anywhere on the map to auto-walk")
    end, 2)
    
    CreateSlider("Walk Speed", 10, 50, Settings.AutoWalkSpeed, function(val)
        Settings.AutoWalkSpeed = val
    end, 3)
    
    -- Ghost Mode
    CreateToggle("Ghost Mode", Settings.GhostMode, function(val)
        Settings.GhostMode = val
        if val then
            EnableGhostMode()
        else
            DisableGhostMode()
        end
    end, 4)
    
    -- Remote Logger
    CreateToggle("Remote Logger", Settings.RemoteLogger, function(val)
        Settings.RemoteLogger = val
        if val then
            print("âœ“ Remote Logger: Active (check console)")
        else
            print("âœ“ Remote Logger: Disabled")
        end
    end, 5)
    
    CreateToggle("Log Only On Clicks", Settings.LogOnlyClicks, function(val)
        Settings.LogOnlyClicks = val
    end, 6)
    
    CreateActionButton("Clear Remote Log", "Wipe all logged remote events", function()
        remoteLog = {}
        print("âœ“ Remote log cleared")
    end, 7)
    
    -- Chat Logger
    CreateToggle("Chat Logger", Settings.ChatLogger, function(val)
        Settings.ChatLogger = val
        if val then
            print("âœ“ Chat Logger: Active (check Logs tab)")
        end
    end, 8)
    
    -- Inventory Scanner
    CreateActionButton("Scan All Inventories", "Check what items other players have", function()
        local results = ScanAllInventories()
        
        print("â•â•â•â•â•â•â• INVENTORY SCAN â•â•â•â•â•â•â•")
        for playerName, inventory in pairs(results) do
            print(playerName .. ":")
            for _, item in ipairs(inventory) do
                print("  â€¢ " .. item.Name .. " [" .. item.Location .. "]")
            end
        end
        print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    end, 9)
    
    -- Chat Bypasser
    local bypassInput = Instance.new("TextBox")
    bypassInput.Size = UDim2.new(1, 0, 0, 35)
    bypassInput.Position = UDim2.new(0, 0, 0, 0)
    bypassInput.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
    bypassInput.PlaceholderText = "Type message to bypass..."
    bypassInput.Text = ""
    bypassInput.TextColor3 = Color3.white
    bypassInput.TextSize = 13
    bypassInput.Font = Settings.UIFont
    bypassInput.ClearTextOnFocus = false
    bypassInput.LayoutOrder = 10
    bypassInput.Parent = toolsPanel
    
    local bypassCorner = Instance.new("UICorner")
    bypassCorner.CornerRadius = UDim.new(0, 6)
    bypassCorner.Parent = bypassInput
    
    CreateActionButton("Transform & Copy Bypassed Text", "Uses unicode lookalikes to avoid filter", function()
        local bypassed = BypassText(bypassInput.Text)
        setclipboard(bypassed)
        print("âœ“ Bypassed text copied to clipboard: " .. bypassed)
    end, 11)
    
    -- Custom Chat Section
    local chatSeparator = Instance.new("Frame")
    chatSeparator.Size = UDim2.new(1, 0, 0, 2)
    chatSeparator.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
    chatSeparator.BorderSizePixel = 0
    chatSeparator.LayoutOrder = 12
    chatSeparator.Parent = toolsPanel
    
    local chatSectionLabel = Instance.new("TextLabel")
    chatSectionLabel.Size = UDim2.new(1, 0, 0, 25)
    chatSectionLabel.BackgroundTransparency = 1
    chatSectionLabel.Text = "ğŸ’¬ CUSTOM CHAT (Visible to All Players)"
    chatSectionLabel.TextColor3 = Settings.UIAccentColor
    chatSectionLabel.TextSize = 13
    chatSectionLabel.Font = Enum.Font.GothamBold
    chatSectionLabel.TextXAlignment = Enum.TextXAlignment.Left
    chatSectionLabel.LayoutOrder = 13
    chatSectionLabel.Parent = toolsPanel
    
    -- Helper functions for tools panel (these create UI elements within toolsPanel)
    local function CreateToolToggle(name, current, callback, layoutOrder)
        local container = Instance.new("Frame")
        container.Size = UDim2.new(1, 0, 0, 35)
        container.BackgroundTransparency = 1
        container.LayoutOrder = layoutOrder
        container.Parent = toolsPanel
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(0.65, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.Text = name
        label.TextColor3 = Color3.fromRGB(220, 220, 220)
        label.TextSize = 13
        label.Font = Settings.UIFont
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = container
        
        local toggle = Instance.new("TextButton")
        toggle.Size = UDim2.new(0, 50, 0, 24)
        toggle.Position = UDim2.new(1, -50, 0.5, -12)
        toggle.BackgroundColor3 = current and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
        toggle.Text = current and "ON" or "OFF"
        toggle.TextColor3 = Color3.white
        toggle.TextSize = 11
        toggle.Font = Enum.Font.GothamBold
        toggle.Parent = container
        
        local toggleCorner = Instance.new("UICorner")
        toggleCorner.CornerRadius = UDim.new(0, 6)
        toggleCorner.Parent = toggle
        
        toggle.MouseButton1Click:Connect(function()
            current = not current
            toggle.BackgroundColor3 = current and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
            toggle.Text = current and "ON" or "OFF"
            callback(current)
        end)
    end
    
    local function CreateToolSlider(name, min, max, current, suffix, callback, layoutOrder)
        local container = Instance.new("Frame")
        container.Size = UDim2.new(1, 0, 0, 45)
        container.BackgroundTransparency = 1
        container.LayoutOrder = layoutOrder
        container.Parent = toolsPanel
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(0.6, 0, 0, 16)
        label.BackgroundTransparency = 1
        label.Text = name
        label.TextColor3 = Color3.fromRGB(220, 220, 220)
        label.TextSize = 13
        label.Font = Settings.UIFont
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = container
        
        local valueLabel = Instance.new("TextLabel")
        valueLabel.Size = UDim2.new(0, 60, 0, 16)
        valueLabel.Position = UDim2.new(1, -60, 0, 0)
        valueLabel.BackgroundTransparency = 1
        valueLabel.Text = tostring(current) .. (suffix or "")
        valueLabel.TextColor3 = Settings.UIAccentColor
        valueLabel.TextSize = 12
        valueLabel.Font = Enum.Font.GothamBold
        valueLabel.TextXAlignment = Enum.TextXAlignment.Right
        valueLabel.Parent = container
        
        local sliderBg = Instance.new("Frame")
        sliderBg.Size = UDim2.new(1, 0, 0, 5)
        sliderBg.Position = UDim2.new(0, 0, 0, 22)
        sliderBg.BackgroundColor3 = Color3.fromRGB(50, 50, 55)
        sliderBg.BorderSizePixel = 0
        sliderBg.Parent = container
        
        local sliderBgCorner = Instance.new("UICorner")
        sliderBgCorner.CornerRadius = UDim.new(0, 3)
        sliderBgCorner.Parent = sliderBg
        
        local sliderFill = Instance.new("Frame")
        sliderFill.Size = UDim2.new((current - min) / (max - min), 0, 1, 0)
        sliderFill.BackgroundColor3 = Settings.UIAccentColor
        sliderFill.BorderSizePixel = 0
        sliderFill.Parent = sliderBg
        
        local sliderFillCorner = Instance.new("UICorner")
        sliderFillCorner.CornerRadius = UDim.new(0, 3)
        sliderFillCorner.Parent = sliderFill
        
        local dragging = false
        
        sliderBg.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
            end
        end)
        
        sliderBg.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
            end
        end)
        
        UserInputService.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local relativeX = Clamp((input.Position.X - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X, 0, 1)
                local value = math.floor(min + (max - min) * relativeX)
                
                sliderFill.Size = UDim2.new(relativeX, 0, 1, 0)
                valueLabel.Text = tostring(value) .. (suffix or "")
                callback(value)
            end
        end)
    end
    
    local function CreateToolColorPicker(name, current, callback, layoutOrder)
        local container = Instance.new("Frame")
        container.Size = UDim2.new(1, 0, 0, 35)
        container.BackgroundTransparency = 1
        container.LayoutOrder = layoutOrder
        container.Parent = toolsPanel
        
        local label = Instance.new("TextLabel")
        label.Size = UDim2.new(0.65, 0, 1, 0)
        label.BackgroundTransparency = 1
        label.Text = name
        label.TextColor3 = Color3.fromRGB(220, 220, 220)
        label.TextSize = 13
        label.Font = Settings.UIFont
        label.TextXAlignment = Enum.TextXAlignment.Left
        label.Parent = container
        
        local colorDisplay = Instance.new("Frame")
        colorDisplay.Size = UDim2.new(0, 50, 0, 24)
        colorDisplay.Position = UDim2.new(1, -50, 0.5, -12)
        colorDisplay.BackgroundColor3 = current
        colorDisplay.BorderSizePixel = 0
        colorDisplay.Parent = container
        
        local colorCorner = Instance.new("UICorner")
        colorCorner.CornerRadius = UDim.new(0, 6)
        colorCorner.Parent = colorDisplay
        
        colorDisplay.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                local colors = {
                    Color3.fromRGB(255, 255, 255),
                    Color3.fromRGB(100, 100, 255),
                    Color3.fromRGB(255, 100, 100),
                    Color3.fromRGB(100, 255, 100),
                    Color3.fromRGB(255, 255, 100),
                    Color3.fromRGB(255, 100, 255),
                    Color3.fromRGB(100, 255, 255),
                    Color3.fromRGB(50, 50, 60),
                }
                
                local currentIdx = 1
                for i, col in ipairs(colors) do
                    if col == colorDisplay.BackgroundColor3 then
                        currentIdx = i
                        break
                    end
                end
                
                local nextColor = colors[(currentIdx % #colors) + 1]
                colorDisplay.BackgroundColor3 = nextColor
                callback(nextColor)
            end
        end)
    end
    
    -- Chat Options
    CreateToolToggle("Enable Custom Chat", Settings.CustomChat, function(val)
        Settings.CustomChat = val
    end, 14)
    
    CreateToolToggle("Show Chat Box (Press /)", Settings.ChatBoxEnabled, function(val)
        Settings.ChatBoxEnabled = val
        if customChatGui then
            customChatGui.Enabled = val
        end
    end, 15)
    
    CreateToolColorPicker("Bubble Color", Settings.ChatBubbleColor, function(col)
        Settings.ChatBubbleColor = col
    end, 16)
    
    CreateToolSlider("Bubble Transparency", 0, 90, Settings.ChatBubbleTransparency, "%", function(val)
        Settings.ChatBubbleTransparency = val
    end, 17)
    
    CreateToolColorPicker("Text Color", Settings.ChatTextColor, function(col)
        Settings.ChatTextColor = col
    end, 18)
    
    CreateToolSlider("Bubble Duration", 1, 15, Settings.ChatBubbleDuration, "s", function(val)
        Settings.ChatBubbleDuration = val
    end, 19)
    
    -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LOGS TAB PANEL â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    local logsPanel = Instance.new("ScrollingFrame")
    logsPanel.Name = "LogsPanel"
    logsPanel.Size = UDim2.new(1, -20, 1, -100)
    logsPanel.Position = UDim2.new(0, 10, 0, 95)
    logsPanel.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
    logsPanel.BorderSizePixel = 0
    logsPanel.ScrollBarThickness = 6
    logsPanel.Visible = false
    logsPanel.Parent = mainContainer
    logsPanel.CanvasSize = UDim2.new(0, 0, 0, 500)
    
    local logsCorner = Instance.new("UICorner")
    logsCorner.CornerRadius = UDim.new(0, 8)
    logsCorner.Parent = logsPanel
    
    local logsLayout = Instance.new("UIListLayout")
    logsLayout.Padding = UDim.new(0, 5)
    logsLayout.SortOrder = Enum.SortOrder.LayoutOrder
    logsLayout.Parent = logsPanel
    
    local logsPadding = Instance.new("UIPadding")
    logsPadding.PaddingTop = UDim.new(0, 10)
    logsPadding.PaddingBottom = UDim.new(0, 10)
    logsPadding.PaddingLeft = UDim.new(0, 10)
    logsPadding.PaddingRight = UDim.new(0, 10)
    logsPadding.Parent = logsPanel
    
    -- Chat Log Section
    local chatLogLabel = Instance.new("TextLabel")
    chatLogLabel.Size = UDim2.new(1, 0, 0, 25)
    chatLogLabel.BackgroundTransparency = 1
    chatLogLabel.Text = "ğŸ’¬ CHAT LOG"
    chatLogLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
    chatLogLabel.TextSize = 14
    chatLogLabel.Font = Enum.Font.GothamBold
    chatLogLabel.TextXAlignment = Enum.TextXAlignment.Left
    chatLogLabel.LayoutOrder = 1
    chatLogLabel.Parent = logsPanel
    
    local chatLogDisplay = Instance.new("TextLabel")
    chatLogDisplay.Size = UDim2.new(1, 0, 0, 150)
    chatLogDisplay.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    chatLogDisplay.BorderSizePixel = 0
    chatLogDisplay.Text = "No chat messages yet..."
    chatLogDisplay.TextColor3 = Color3.fromRGB(200, 200, 200)
    chatLogDisplay.TextSize = 12
    chatLogDisplay.Font = Enum.Font.Code
    chatLogDisplay.TextXAlignment = Enum.TextXAlignment.Left
    chatLogDisplay.TextYAlignment = Enum.TextYAlignment.Top
    chatLogDisplay.TextWrapped = true
    chatLogDisplay.LayoutOrder = 2
    chatLogDisplay.Parent = logsPanel
    
    local chatLogCorner = Instance.new("UICorner")
    chatLogCorner.CornerRadius = UDim.new(0, 6)
    chatLogCorner.Parent = chatLogDisplay
    
    local chatLogPadding = Instance.new("UIPadding")
    chatLogPadding.PaddingTop = UDim.new(0, 8)
    chatLogPadding.PaddingLeft = UDim.new(0, 8)
    chatLogPadding.PaddingRight = UDim.new(0, 8)
    chatLogPadding.Parent = chatLogDisplay
    
    -- Remote Log Section
    local remoteLogLabel = Instance.new("TextLabel")
    remoteLogLabel.Size = UDim2.new(1, 0, 0, 25)
    remoteLogLabel.BackgroundTransparency = 1
    remoteLogLabel.Text = "ğŸ“¡ REMOTE LOG"
    remoteLogLabel.TextColor3 = Color3.fromRGB(255, 150, 100)
    remoteLogLabel.TextSize = 14
    remoteLogLabel.Font = Enum.Font.GothamBold
    remoteLogLabel.TextXAlignment = Enum.TextXAlignment.Left
    remoteLogLabel.LayoutOrder = 3
    remoteLogLabel.Parent = logsPanel
    
    local remoteLogDisplay = Instance.new("TextLabel")
    remoteLogDisplay.Size = UDim2.new(1, 0, 0, 150)
    remoteLogDisplay.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    remoteLogDisplay.BorderSizePixel = 0
    remoteLogDisplay.Text = "No remote events logged yet..."
    remoteLogDisplay.TextColor3 = Color3.fromRGB(200, 200, 200)
    remoteLogDisplay.TextSize = 12
    remoteLogDisplay.Font = Enum.Font.Code
    remoteLogDisplay.TextXAlignment = Enum.TextXAlignment.Left
    remoteLogDisplay.TextYAlignment = Enum.TextYAlignment.Top
    remoteLogDisplay.TextWrapped = true
    remoteLogDisplay.LayoutOrder = 4
    remoteLogDisplay.Parent = logsPanel
    
    local remoteLogCorner = Instance.new("UICorner")
    remoteLogCorner.CornerRadius = UDim.new(0, 6)
    remoteLogCorner.Parent = remoteLogDisplay
    
    local remoteLogPadding = Instance.new("UIPadding")
    remoteLogPadding.PaddingTop = UDim.new(0, 8)
    remoteLogPadding.PaddingLeft = UDim.new(0, 8)
    remoteLogPadding.PaddingRight = UDim.new(0, 8)
    remoteLogPadding.Parent = remoteLogDisplay
    
    -- Update logs display in real-time
    task.spawn(function()
        while task.wait(1) do
            if logsPanel.Visible then
                -- Update chat log
                local chatText = ""
                local startIdx = math.max(1, #chatLog - 10)
                for i = startIdx, #chatLog do
                    local entry = chatLog[i]
                    chatText = chatText .. string.format("[%s] %s: %s\n", 
                        entry.Time, entry.Speaker, entry.Message)
                end
                chatLogDisplay.Text = chatText ~= "" and chatText or "No chat messages yet..."
                
                -- Update remote log
                local remoteText = ""
                local startIdx2 = math.max(1, #remoteLog - 10)
                for i = startIdx2, #remoteLog do
                    local entry = remoteLog[i]
                    remoteText = remoteText .. string.format("[%s] %s:%s\n", 
                        entry.Time, entry.Method, entry.Name)
                end
                remoteLogDisplay.Text = remoteText ~= "" and remoteText or "No remote events logged yet..."
            end
        end
    end)
    
    -- Update function
    local function UpdateUI()
        flightStatus.Text = Settings.Flight and "ON" or "OFF"
        flightStatus.TextColor3 = Settings.Flight and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
        
        noclipStatus.Text = Settings.Noclip and "ON" or "OFF"
        noclipStatus.TextColor3 = Settings.Noclip and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
        
        espStatus.Text = Settings.ESP and "ON" or "OFF"
        espStatus.TextColor3 = Settings.ESP and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100)
        
        speedStatus.Text = tostring(Settings.Speed)
    end
    
    -- Make draggable (works on both PC and mobile)
    local dragging, dragInput, dragStart, startPos
    
    local function UpdateDrag(input)
        local delta = input.Position - dragStart
        mainContainer.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + delta.X,
            startPos.Y.Scale,
            startPos.Y.Offset + delta.Y
        )
    end
    
    titleBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = mainContainer.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    titleBar.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            UpdateDrag(input)
        end
    end)
    
    return UpdateUI
end

local UpdateUI = CreateUI()

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                         KEYBIND SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

table.insert(connections, UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    -- PANIC KEY: Instantly hide everything
    if input.KeyCode == Settings.PanicKey then
        Settings.ESP = false
        Settings.Flight = false
        Settings.Noclip = false
        
        -- Hide UI
        if gui then
            gui.Enabled = false
        end
        
        -- Clear ESP immediately
        for _, espData in pairs(espObjects) do
            if espData.NameLabel then espData.NameLabel.Visible = false end
            if espData.DistanceLabel then espData.DistanceLabel.Visible = false end
            for _, box in pairs(espData.Boxes) do
                if box then box.Visible = false end
            end
        end
        
        -- Restore character state
        local char = GetChar()
        if char then
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum then
                hum:ChangeState(Enum.HumanoidStateType.GettingUp)
            end
            for _, part in ipairs(cachedParts) do
                if part and part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
        
        UpdateUI()
        print("âš ï¸ PANIC MODE: All features disabled")
    end
    
    -- TRIPLE TAP UI TOGGLE (for streamer mode)
    if input.KeyCode == Settings.ToggleUI then
        local currentTime = tick()
        
        -- Clear old taps outside the window
        while #panicTaps > 0 and currentTime - panicTaps[1] > TRIPLE_TAP_WINDOW do
            table.remove(panicTaps, 1)
        end
        
        -- Add new tap
        table.insert(panicTaps, currentTime)
        
        -- Check for triple tap
        if #panicTaps >= 3 then
            panicTaps = {} -- Reset
            gui.Enabled = not gui.Enabled
            print("âœ“ Triple Tap Detected: UI " .. (gui.Enabled and "Shown" or "Hidden"))
        end
        
        return -- Don't process single tap toggle
    end
    
    -- Toggle Flight
    if input.KeyCode == Settings.ToggleFlight then
        Settings.Flight = not Settings.Flight
        UpdateUI()
        
        -- Restore gravity if disabled
        if not Settings.Flight then
            local char = GetChar()
            if char then
                local hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                    hum:ChangeState(Enum.HumanoidStateType.GettingUp)
                end
            end
        end
    end
    
    -- Toggle Noclip
    if input.KeyCode == Settings.ToggleNoclip then
        Settings.Noclip = not Settings.Noclip
        UpdateUI()
        
        -- Restore collisions if disabled
        if not Settings.Noclip then
            for _, part in ipairs(cachedParts) do
                if part and part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
    end
    
    -- Toggle ESP
    if input.KeyCode == Settings.ToggleESP then
        Settings.ESP = not Settings.ESP
        UpdateUI()
    end
    
    -- Speed Up
    if input.KeyCode == Settings.SpeedUp then
        Settings.Speed = Clamp(Settings.Speed + 10, 10, 300)
        UpdateUI()
    end
    
    -- Speed Down
    if input.KeyCode == Settings.SpeedDown then
        Settings.Speed = Clamp(Settings.Speed - 10, 10, 300)
        UpdateUI()
    end
end))

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
--                         INITIALIZATION
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print([[
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         ZENITH V17 - MOBILE & PC UNIVERSAL HUB               â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ“± MOBILE SUPPORT:                                          â•‘
â•‘  âœ“ Bottom-Right Toggle Button (Tap "Z" to open)             â•‘
â•‘  âœ“ Touch-Friendly UI with Smooth Animations                 â•‘
â•‘  âœ“ Optimized Layout for Small Screens                       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  CORE FEATURES:                                              â•‘
â•‘  âœ“ Metamethod Hooked Property Spoofing                      â•‘
â•‘  âœ“ Humanized Flight with Natural Variance                   â•‘
â•‘  âœ“ ESP with Wallcheck & Visibility Modes                    â•‘
â•‘  âœ“ Custom Chat (Visible to Everyone - Bypasses Filter)      â•‘
â•‘  âœ“ Selective Noclip (Walk-Through Only)                     â•‘
â•‘  âœ“ Fake Lag System (Position Buffering)                     â•‘
â•‘  âœ“ Streamer Mode (CoreGui + Triple-Tap)                     â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ADVANCED TOOLS:                                             â•‘
â•‘  âœ“ Smart Auto-Walk (PathfindingService)                     â•‘
â•‘  âœ“ Ghost Mode (Desync Scouting)                             â•‘
â•‘  âœ“ Remote Event Logger (Selective)                              
â•‘  âœ“ Chat Logger & Bypasser                                   â•‘
â•‘  âœ“ Inventory Scanner (Check Player Items)                    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  MOBILE: Tap circular "Z" button (bottom-right corner)       â•‘
â•‘  PC: [F] Flight [N] Noclip [E] ESP [P] PANIC [/] Chat        â•‘
â•‘  [RCtrl x3] Triple-Tap  â€¢  4 Tabs: Main/Tools/Custom/Logs    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ® Device Detected: ]] .. (isMobileDevice and "MOBILE ğŸ“±" or "PC ğŸ–¥ï¸") .. [[

]])
